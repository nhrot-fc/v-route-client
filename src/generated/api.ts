/* tslint:disable */
/* eslint-disable */
/**
 * PLG System Management API
 * API para la gestión del sistema PLG (Propane Liquid Gas). Incluye gestión de vehículos, mantenimientos, bloqueos, incidentes y órdenes.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: plgsystem@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ActionDTO
 */
export interface ActionDTO {
    /**
     * 
     * @type {string}
     * @memberof ActionDTO
     */
    'type'?: ActionDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ActionDTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {Array<Position>}
     * @memberof ActionDTO
     */
    'path'?: Array<Position>;
    /**
     * 
     * @type {number}
     * @memberof ActionDTO
     */
    'glpDelivered'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDTO
     */
    'glpLoaded'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDTO
     */
    'fuelConsumedGal'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActionDTO
     */
    'fuelRefueledGal'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActionDTO
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActionDTO
     */
    'depotId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActionDTO
     */
    'progress'?: number;
}

export const ActionDTOTypeEnum = {
    Drive: 'DRIVE',
    Refuel: 'REFUEL',
    Reload: 'RELOAD',
    Serve: 'SERVE',
    Maintenance: 'MAINTENANCE',
    Wait: 'WAIT'
} as const;

export type ActionDTOTypeEnum = typeof ActionDTOTypeEnum[keyof typeof ActionDTOTypeEnum];

/**
 * 
 * @export
 * @interface Blockage
 */
export interface Blockage {
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'linePoints'?: string;
    /**
     * 
     * @type {Array<Position>}
     * @memberof Blockage
     */
    'lines'?: Array<Position>;
}
/**
 * 
 * @export
 * @interface BlockageDTO
 */
export interface BlockageDTO {
    /**
     * 
     * @type {string}
     * @memberof BlockageDTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockageDTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {Array<Position>}
     * @memberof BlockageDTO
     */
    'blockageLines'?: Array<Position>;
}
/**
 * 
 * @export
 * @interface DeliveryRecordDTO
 */
export interface DeliveryRecordDTO {
    /**
     * 
     * @type {string}
     * @memberof DeliveryRecordDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeliveryRecordDTO
     */
    'volumeM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeliveryRecordDTO
     */
    'serveDate'?: string;
}
/**
 * 
 * @export
 * @interface Depot
 */
export interface Depot {
    /**
     * 
     * @type {string}
     * @memberof Depot
     */
    'id'?: string;
    /**
     * 
     * @type {Position}
     * @memberof Depot
     */
    'position'?: Position;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof Depot
     */
    'type'?: DepotTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'currentGlpM3'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Depot
     */
    'auxiliary'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Depot
     */
    'main'?: boolean;
}

export const DepotTypeEnum = {
    Main: 'MAIN',
    Auxiliary: 'AUXILIARY',
    Temporary: 'TEMPORARY'
} as const;

export type DepotTypeEnum = typeof DepotTypeEnum[keyof typeof DepotTypeEnum];

/**
 * 
 * @export
 * @interface DepotDTO
 */
export interface DepotDTO {
    /**
     * 
     * @type {string}
     * @memberof DepotDTO
     */
    'id'?: string;
    /**
     * 
     * @type {Position}
     * @memberof DepotDTO
     */
    'position'?: Position;
    /**
     * 
     * @type {number}
     * @memberof DepotDTO
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof DepotDTO
     */
    'type'?: DepotDTOTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DepotDTO
     */
    'currentGlpM3'?: number;
}

export const DepotDTOTypeEnum = {
    Main: 'MAIN',
    Auxiliary: 'AUXILIARY',
    Temporary: 'TEMPORARY'
} as const;

export type DepotDTOTypeEnum = typeof DepotDTOTypeEnum[keyof typeof DepotDTOTypeEnum];

/**
 * 
 * @export
 * @interface Incident
 */
export interface Incident {
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'id'?: string;
    /**
     * 
     * @type {Vehicle}
     * @memberof Incident
     */
    'vehicle'?: Vehicle;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'type'?: IncidentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'shift'?: IncidentShiftEnum;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'occurrenceTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Incident
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'immobilizationEndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'availabilityTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Incident
     */
    'returnToDepotRequired'?: boolean;
}

export const IncidentTypeEnum = {
    Ti1: 'TI1',
    Ti2: 'TI2',
    Ti3: 'TI3'
} as const;

export type IncidentTypeEnum = typeof IncidentTypeEnum[keyof typeof IncidentTypeEnum];
export const IncidentShiftEnum = {
    T1: 'T1',
    T2: 'T2',
    T3: 'T3'
} as const;

export type IncidentShiftEnum = typeof IncidentShiftEnum[keyof typeof IncidentShiftEnum];

/**
 * 
 * @export
 * @interface IncidentCreateDTO
 */
export interface IncidentCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof IncidentCreateDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentCreateDTO
     */
    'type'?: IncidentCreateDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IncidentCreateDTO
     */
    'occurrenceTime'?: string;
}

export const IncidentCreateDTOTypeEnum = {
    Ti1: 'TI1',
    Ti2: 'TI2',
    Ti3: 'TI3'
} as const;

export type IncidentCreateDTOTypeEnum = typeof IncidentCreateDTOTypeEnum[keyof typeof IncidentCreateDTOTypeEnum];

/**
 * 
 * @export
 * @interface IncidentDTO
 */
export interface IncidentDTO {
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'type'?: IncidentDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'shift'?: IncidentDTOShiftEnum;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'occurrenceTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentDTO
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'immobilizationEndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'availabilityTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentDTO
     */
    'returnToDepotRequired'?: boolean;
}

export const IncidentDTOTypeEnum = {
    Ti1: 'TI1',
    Ti2: 'TI2',
    Ti3: 'TI3'
} as const;

export type IncidentDTOTypeEnum = typeof IncidentDTOTypeEnum[keyof typeof IncidentDTOTypeEnum];
export const IncidentDTOShiftEnum = {
    T1: 'T1',
    T2: 'T2',
    T3: 'T3'
} as const;

export type IncidentDTOShiftEnum = typeof IncidentDTOShiftEnum[keyof typeof IncidentDTOShiftEnum];

/**
 * 
 * @export
 * @interface Maintenance
 */
export interface Maintenance {
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'id'?: string;
    /**
     * 
     * @type {Vehicle}
     * @memberof Maintenance
     */
    'vehicle'?: Vehicle;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'assignedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'realStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'realEnd'?: string;
}
/**
 * 
 * @export
 * @interface MaintenanceCreateDTO
 */
export interface MaintenanceCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceCreateDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceCreateDTO
     */
    'assignedDate'?: string;
}
/**
 * 
 * @export
 * @interface MaintenanceDTO
 */
export interface MaintenanceDTO {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'assignedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'realStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'realEnd'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MaintenanceDTO
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MaintenanceDTO
     */
    'durationHours'?: number;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'arrivalTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'deadlineTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'glpRequestM3'?: number;
    /**
     * 
     * @type {Position}
     * @memberof Order
     */
    'position'?: Position;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'remainingGlpM3'?: number;
    /**
     * 
     * @type {Array<ServeRecord>}
     * @memberof Order
     */
    'serveRecords'?: Array<ServeRecord>;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'delivered'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderDTO
 */
export interface OrderDTO {
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'arrivalTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'deadlineTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'glpRequestM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'remainingGlpM3'?: number;
    /**
     * 
     * @type {Position}
     * @memberof OrderDTO
     */
    'position'?: Position;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDTO
     */
    'delivered'?: boolean;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface ServeRecord
 */
export interface ServeRecord {
    /**
     * 
     * @type {string}
     * @memberof ServeRecord
     */
    'id'?: string;
    /**
     * 
     * @type {Vehicle}
     * @memberof ServeRecord
     */
    'vehicle'?: Vehicle;
    /**
     * 
     * @type {Order}
     * @memberof ServeRecord
     */
    'order'?: Order;
    /**
     * 
     * @type {number}
     * @memberof ServeRecord
     */
    'glpVolumeM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServeRecord
     */
    'serveDate'?: string;
}
/**
 * 
 * @export
 * @interface ServeRecordDTO
 */
export interface ServeRecordDTO {
    /**
     * 
     * @type {string}
     * @memberof ServeRecordDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServeRecordDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServeRecordDTO
     */
    'orderId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServeRecordDTO
     */
    'glpVolumeM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServeRecordDTO
     */
    'serveDate'?: string;
}
/**
 * 
 * @export
 * @interface SimulationCreateDTO
 */
export interface SimulationCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationCreateDTO
     */
    'startDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationCreateDTO
     */
    'endDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationCreateDTO
     */
    'type'?: SimulationCreateDTOTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SimulationCreateDTO
     */
    'taVehicles'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationCreateDTO
     */
    'tbVehicles'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationCreateDTO
     */
    'tcVehicles'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationCreateDTO
     */
    'tdVehicles'?: number;
}

export const SimulationCreateDTOTypeEnum = {
    DailyOperations: 'DAILY_OPERATIONS',
    Weekly: 'WEEKLY',
    Infinite: 'INFINITE',
    Custom: 'CUSTOM',
    Benchmark: 'BENCHMARK'
} as const;

export type SimulationCreateDTOTypeEnum = typeof SimulationCreateDTOTypeEnum[keyof typeof SimulationCreateDTOTypeEnum];

/**
 * 
 * @export
 * @interface SimulationDTO
 */
export interface SimulationDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    'simulatedCurrentTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    'creationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    'realStartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    'realEndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    'type'?: SimulationDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SimulationDTO
     */
    'status'?: SimulationDTOStatusEnum;
    /**
     * 
     * @type {SimulationStateDTO}
     * @memberof SimulationDTO
     */
    'state'?: SimulationStateDTO;
}

export const SimulationDTOTypeEnum = {
    DailyOperations: 'DAILY_OPERATIONS',
    Weekly: 'WEEKLY',
    Infinite: 'INFINITE',
    Custom: 'CUSTOM',
    Benchmark: 'BENCHMARK'
} as const;

export type SimulationDTOTypeEnum = typeof SimulationDTOTypeEnum[keyof typeof SimulationDTOTypeEnum];
export const SimulationDTOStatusEnum = {
    Running: 'RUNNING',
    Paused: 'PAUSED',
    Finished: 'FINISHED',
    Error: 'ERROR'
} as const;

export type SimulationDTOStatusEnum = typeof SimulationDTOStatusEnum[keyof typeof SimulationDTOStatusEnum];

/**
 * 
 * @export
 * @interface SimulationStateDTO
 */
export interface SimulationStateDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationStateDTO
     */
    'simulationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationStateDTO
     */
    'currentTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationStateDTO
     */
    'status'?: SimulationStateDTOStatusEnum;
    /**
     * 
     * @type {Array<VehicleDTO>}
     * @memberof SimulationStateDTO
     */
    'vehicles'?: Array<VehicleDTO>;
    /**
     * 
     * @type {DepotDTO}
     * @memberof SimulationStateDTO
     */
    'mainDepot'?: DepotDTO;
    /**
     * 
     * @type {Array<DepotDTO>}
     * @memberof SimulationStateDTO
     */
    'auxDepots'?: Array<DepotDTO>;
    /**
     * 
     * @type {Array<OrderDTO>}
     * @memberof SimulationStateDTO
     */
    'pendingOrders'?: Array<OrderDTO>;
    /**
     * 
     * @type {Array<Blockage>}
     * @memberof SimulationStateDTO
     */
    'activeBlockages'?: Array<Blockage>;
    /**
     * 
     * @type {Array<IncidentDTO>}
     * @memberof SimulationStateDTO
     */
    'activeIncidents'?: Array<IncidentDTO>;
    /**
     * 
     * @type {Array<MaintenanceDTO>}
     * @memberof SimulationStateDTO
     */
    'scheduledMaintenances'?: Array<MaintenanceDTO>;
    /**
     * 
     * @type {Array<VehiclePlanDTO>}
     * @memberof SimulationStateDTO
     */
    'currentVehiclePlans'?: Array<VehiclePlanDTO>;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'pendingOrdersCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'deliveredOrdersCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'overdueOrdersCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'availableVehiclesCount'?: number;
}

export const SimulationStateDTOStatusEnum = {
    Running: 'RUNNING',
    Paused: 'PAUSED',
    Finished: 'FINISHED',
    Error: 'ERROR'
} as const;

export type SimulationStateDTOStatusEnum = typeof SimulationStateDTOStatusEnum[keyof typeof SimulationStateDTOStatusEnum];

/**
 * 
 * @export
 * @interface Vehicle
 */
export interface Vehicle {
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'type'?: VehicleTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'fuelCapacityGal'?: number;
    /**
     * 
     * @type {Position}
     * @memberof Vehicle
     */
    'currentPosition'?: Position;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentGlpM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentFuelGal'?: number;
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'status'?: VehicleStatusEnum;
    /**
     * 
     * @type {Array<Incident>}
     * @memberof Vehicle
     */
    'incidents'?: Array<Incident>;
    /**
     * 
     * @type {Array<ServeRecord>}
     * @memberof Vehicle
     */
    'serveRecords'?: Array<ServeRecord>;
    /**
     * 
     * @type {Array<Maintenance>}
     * @memberof Vehicle
     */
    'maintenances'?: Array<Maintenance>;
    /**
     * 
     * @type {boolean}
     * @memberof Vehicle
     */
    'available'?: boolean;
}

export const VehicleTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;

export type VehicleTypeEnum = typeof VehicleTypeEnum[keyof typeof VehicleTypeEnum];
export const VehicleStatusEnum = {
    Available: 'AVAILABLE',
    Driving: 'DRIVING',
    Maintenance: 'MAINTENANCE',
    Refueling: 'REFUELING',
    Reloading: 'RELOADING',
    Serving: 'SERVING',
    Incident: 'INCIDENT',
    Idle: 'IDLE'
} as const;

export type VehicleStatusEnum = typeof VehicleStatusEnum[keyof typeof VehicleStatusEnum];

/**
 * 
 * @export
 * @interface VehicleDTO
 */
export interface VehicleDTO {
    /**
     * 
     * @type {string}
     * @memberof VehicleDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehicleDTO
     */
    'type'?: VehicleDTOTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'fuelCapacityGal'?: number;
    /**
     * 
     * @type {Position}
     * @memberof VehicleDTO
     */
    'currentPosition'?: Position;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'currentGlpM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'currentFuelGal'?: number;
    /**
     * 
     * @type {string}
     * @memberof VehicleDTO
     */
    'status'?: VehicleDTOStatusEnum;
}

export const VehicleDTOTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;

export type VehicleDTOTypeEnum = typeof VehicleDTOTypeEnum[keyof typeof VehicleDTOTypeEnum];
export const VehicleDTOStatusEnum = {
    Available: 'AVAILABLE',
    Driving: 'DRIVING',
    Maintenance: 'MAINTENANCE',
    Refueling: 'REFUELING',
    Reloading: 'RELOADING',
    Serving: 'SERVING',
    Incident: 'INCIDENT',
    Idle: 'IDLE'
} as const;

export type VehicleDTOStatusEnum = typeof VehicleDTOStatusEnum[keyof typeof VehicleDTOStatusEnum];

/**
 * 
 * @export
 * @interface VehiclePlanDTO
 */
export interface VehiclePlanDTO {
    /**
     * 
     * @type {string}
     * @memberof VehiclePlanDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {Array<ActionDTO>}
     * @memberof VehiclePlanDTO
     */
    'actions'?: Array<ActionDTO>;
    /**
     * 
     * @type {string}
     * @memberof VehiclePlanDTO
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehiclePlanDTO
     */
    'endTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof VehiclePlanDTO
     */
    'currentActionIndex'?: number;
}

/**
 * BlockageControllerApi - axios parameter creator
 * @export
 */
export const BlockageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BlockageDTO} blockageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5: async (blockageDTO: BlockageDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockageDTO' is not null or undefined
            assertParamExists('create5', 'blockageDTO', blockageDTO)
            const localVarPath = `/api/blockages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockageDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<BlockageDTO>} blockageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulk1: async (blockageDTO: Array<BlockageDTO>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockageDTO' is not null or undefined
            assertParamExists('createBulk1', 'blockageDTO', blockageDTO)
            const localVarPath = `/api/blockages/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockageDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete4', 'id', id)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById5: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById5', 'id', id)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [activeAt] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list5: async (activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/blockages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeAt !== undefined) {
                localVarQueryParameter['activeAt'] = (activeAt as any instanceof Date) ?
                    (activeAt as any).toISOString() :
                    activeAt;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: async (id: string, blockage: Blockage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update3', 'id', id)
            // verify required parameter 'blockage' is not null or undefined
            assertParamExists('update3', 'blockage', blockage)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockageControllerApi - functional programming interface
 * @export
 */
export const BlockageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BlockageDTO} blockageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create5(blockageDTO: BlockageDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create5(blockageDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.create5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<BlockageDTO>} blockageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBulk1(blockageDTO: Array<BlockageDTO>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Blockage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBulk1(blockageDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.createBulk1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete4(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete4(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.delete4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById5(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById5(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.getById5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [activeAt] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list5(activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list5(activeAt, startTime, endTime, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.list5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3(id: string, blockage: Blockage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update3(id, blockage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.update3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlockageControllerApi - factory interface
 * @export
 */
export const BlockageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockageControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {BlockageDTO} blockageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5(blockageDTO: BlockageDTO, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.create5(blockageDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<BlockageDTO>} blockageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulk1(blockageDTO: Array<BlockageDTO>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Blockage>> {
            return localVarFp.createBulk1(blockageDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById5(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.getById5(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [activeAt] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list5(activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list5(activeAt, startTime, endTime, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(id: string, blockage: Blockage, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.update3(id, blockage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockageControllerApi - object-oriented interface
 * @export
 * @class BlockageControllerApi
 * @extends {BaseAPI}
 */
export class BlockageControllerApi extends BaseAPI {
    /**
     * 
     * @param {BlockageDTO} blockageDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public create5(blockageDTO: BlockageDTO, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).create5(blockageDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<BlockageDTO>} blockageDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public createBulk1(blockageDTO: Array<BlockageDTO>, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).createBulk1(blockageDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public delete4(id: string, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).delete4(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public getById5(id: string, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).getById5(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [activeAt] 
     * @param {string} [startTime] 
     * @param {string} [endTime] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public list5(activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).list5(activeAt, startTime, endTime, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {Blockage} blockage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public update3(id: string, blockage: Blockage, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).update3(id, blockage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardOverview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/system-health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrgentOrders: async (hoursAhead?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/urgent-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hoursAhead !== undefined) {
                localVarQueryParameter['hoursAhead'] = hoursAhead;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleStatusBreakdown: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/vehicle-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardOverview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardOverview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboardOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getSystemHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrgentOrders(hoursAhead, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getUrgentOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehicleStatusBreakdown(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehicleStatusBreakdown(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getVehicleStatusBreakdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardOverview(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDashboardOverview(options).then((request) => request(axios, basePath));
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSystemHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.getUrgentOrders(hoursAhead, options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleStatusBreakdown(options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.getVehicleStatusBreakdown(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
     * @summary Obtener resumen del dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardOverview(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardOverview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
     * @summary Obtener salud del sistema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getSystemHealth(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getSystemHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve las órdenes que vencen dentro del plazo especificado
     * @summary Obtener órdenes urgentes
     * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getUrgentOrders(hoursAhead, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve un desglose de vehículos agrupados por su estado operativo
     * @summary Obtener estado de vehículos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getVehicleStatusBreakdown(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getVehicleStatusBreakdown(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepotControllerApi - axios parameter creator
 * @export
 */
export const DepotControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (depot: Depot, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'depot' is not null or undefined
            assertParamExists('create4', 'depot', depot)
            const localVarPath = `/api/depots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete3', 'id', id)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById4', 'id', id)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {List4TypeEnum} [type] 
         * @param {boolean} [isMain] 
         * @param {number} [minGlpCapacity] 
         * @param {number} [minCurrentGlp] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list4: async (type?: List4TypeEnum, isMain?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/depots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (isMain !== undefined) {
                localVarQueryParameter['isMain'] = isMain;
            }

            if (minGlpCapacity !== undefined) {
                localVarQueryParameter['minGlpCapacity'] = minGlpCapacity;
            }

            if (minCurrentGlp !== undefined) {
                localVarQueryParameter['minCurrentGlp'] = minCurrentGlp;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: async (id: string, depot: Depot, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update2', 'id', id)
            // verify required parameter 'depot' is not null or undefined
            assertParamExists('update2', 'depot', depot)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepotControllerApi - functional programming interface
 * @export
 */
export const DepotControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepotControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(depot: Depot, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create4(depot, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.create4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.delete3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById4(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById4(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.getById4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {List4TypeEnum} [type] 
         * @param {boolean} [isMain] 
         * @param {number} [minGlpCapacity] 
         * @param {number} [minCurrentGlp] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list4(type?: List4TypeEnum, isMain?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list4(type, isMain, minGlpCapacity, minCurrentGlp, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.list4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update2(id: string, depot: Depot, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update2(id, depot, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.update2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepotControllerApi - factory interface
 * @export
 */
export const DepotControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepotControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(depot: Depot, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.create4(depot, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.getById4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {List4TypeEnum} [type] 
         * @param {boolean} [isMain] 
         * @param {number} [minGlpCapacity] 
         * @param {number} [minCurrentGlp] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list4(type?: List4TypeEnum, isMain?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list4(type, isMain, minGlpCapacity, minCurrentGlp, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(id: string, depot: Depot, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.update2(id, depot, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepotControllerApi - object-oriented interface
 * @export
 * @class DepotControllerApi
 * @extends {BaseAPI}
 */
export class DepotControllerApi extends BaseAPI {
    /**
     * 
     * @param {Depot} depot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public create4(depot: Depot, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).create4(depot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public delete3(id: string, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).delete3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public getById4(id: string, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).getById4(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {List4TypeEnum} [type] 
     * @param {boolean} [isMain] 
     * @param {number} [minGlpCapacity] 
     * @param {number} [minCurrentGlp] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public list4(type?: List4TypeEnum, isMain?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).list4(type, isMain, minGlpCapacity, minCurrentGlp, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {Depot} depot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public update2(id: string, depot: Depot, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).update2(id, depot, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const List4TypeEnum = {
    Main: 'MAIN',
    Auxiliary: 'AUXILIARY',
    Temporary: 'TEMPORARY'
} as const;
export type List4TypeEnum = typeof List4TypeEnum[keyof typeof List4TypeEnum];


/**
 * IncidentControllerApi - axios parameter creator
 * @export
 */
export const IncidentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IncidentCreateDTO} incidentCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (incidentCreateDTO: IncidentCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incidentCreateDTO' is not null or undefined
            assertParamExists('create3', 'incidentCreateDTO', incidentCreateDTO)
            const localVarPath = `/api/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incidentCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById3', 'id', id)
            const localVarPath = `/api/incidents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {List3TypeEnum} [type] 
         * @param {List3ShiftEnum} [shift] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [resolved] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list3: async (vehicleId?: string, type?: List3TypeEnum, shift?: List3ShiftEnum, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicleId'] = vehicleId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (shift !== undefined) {
                localVarQueryParameter['shift'] = shift;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (resolved !== undefined) {
                localVarQueryParameter['resolved'] = resolved;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIncident: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resolveIncident', 'id', id)
            const localVarPath = `/api/incidents/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncidentControllerApi - functional programming interface
 * @export
 */
export const IncidentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncidentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {IncidentCreateDTO} incidentCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(incidentCreateDTO: IncidentCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create3(incidentCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.create3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById3(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById3(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.getById3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {List3TypeEnum} [type] 
         * @param {List3ShiftEnum} [shift] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [resolved] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list3(vehicleId?: string, type?: List3TypeEnum, shift?: List3ShiftEnum, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list3(vehicleId, type, shift, startDate, endDate, resolved, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.list3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveIncident(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveIncident(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.resolveIncident']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IncidentControllerApi - factory interface
 * @export
 */
export const IncidentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncidentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {IncidentCreateDTO} incidentCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(incidentCreateDTO: IncidentCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<IncidentDTO> {
            return localVarFp.create3(incidentCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: string, options?: RawAxiosRequestConfig): AxiosPromise<IncidentDTO> {
            return localVarFp.getById3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {List3TypeEnum} [type] 
         * @param {List3ShiftEnum} [shift] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [resolved] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list3(vehicleId?: string, type?: List3TypeEnum, shift?: List3ShiftEnum, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list3(vehicleId, type, shift, startDate, endDate, resolved, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIncident(id: string, options?: RawAxiosRequestConfig): AxiosPromise<IncidentDTO> {
            return localVarFp.resolveIncident(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncidentControllerApi - object-oriented interface
 * @export
 * @class IncidentControllerApi
 * @extends {BaseAPI}
 */
export class IncidentControllerApi extends BaseAPI {
    /**
     * 
     * @param {IncidentCreateDTO} incidentCreateDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public create3(incidentCreateDTO: IncidentCreateDTO, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).create3(incidentCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public getById3(id: string, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).getById3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [vehicleId] 
     * @param {List3TypeEnum} [type] 
     * @param {List3ShiftEnum} [shift] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [resolved] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public list3(vehicleId?: string, type?: List3TypeEnum, shift?: List3ShiftEnum, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).list3(vehicleId, type, shift, startDate, endDate, resolved, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public resolveIncident(id: string, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).resolveIncident(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const List3TypeEnum = {
    Ti1: 'TI1',
    Ti2: 'TI2',
    Ti3: 'TI3'
} as const;
export type List3TypeEnum = typeof List3TypeEnum[keyof typeof List3TypeEnum];
/**
 * @export
 */
export const List3ShiftEnum = {
    T1: 'T1',
    T2: 'T2',
    T3: 'T3'
} as const;
export type List3ShiftEnum = typeof List3ShiftEnum[keyof typeof List3ShiftEnum];


/**
 * MaintenanceControllerApi - axios parameter creator
 * @export
 */
export const MaintenanceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaintenance: async (maintenanceCreateDTO: MaintenanceCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maintenanceCreateDTO' is not null or undefined
            assertParamExists('createMaintenance', 'maintenanceCreateDTO', maintenanceCreateDTO)
            const localVarPath = `/api/maintenances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(maintenanceCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaintenanceById', 'id', id)
            const localVarPath = `/api/maintenances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveMaintenances: async (paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/maintenances/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [date] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMaintenances: async (vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/maintenances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicleId'] = vehicleId;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaintenanceControllerApi - functional programming interface
 * @export
 */
export const MaintenanceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintenanceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMaintenance(maintenanceCreateDTO: MaintenanceCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMaintenance(maintenanceCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.createMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.getMaintenanceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveMaintenances(paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveMaintenances(paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.listActiveMaintenances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [date] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMaintenances(vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMaintenances(vehicleId, date, startDate, endDate, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.listMaintenances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaintenanceControllerApi - factory interface
 * @export
 */
export const MaintenanceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaintenanceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaintenance(maintenanceCreateDTO: MaintenanceCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceDTO> {
            return localVarFp.createMaintenance(maintenanceCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceDTO> {
            return localVarFp.getMaintenanceById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveMaintenances(paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listActiveMaintenances(paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [date] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMaintenances(vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listMaintenances(vehicleId, date, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaintenanceControllerApi - object-oriented interface
 * @export
 * @class MaintenanceControllerApi
 * @extends {BaseAPI}
 */
export class MaintenanceControllerApi extends BaseAPI {
    /**
     * 
     * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public createMaintenance(maintenanceCreateDTO: MaintenanceCreateDTO, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).createMaintenance(maintenanceCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public getMaintenanceById(id: string, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).getMaintenanceById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public listActiveMaintenances(paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).listActiveMaintenances(paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [vehicleId] 
     * @param {string} [date] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public listMaintenances(vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).listMaintenances(vehicleId, date, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderControllerApi - axios parameter creator
 * @export
 */
export const OrderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (orderDTO: OrderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderDTO' is not null or undefined
            assertParamExists('create2', 'orderDTO', orderDTO)
            const localVarPath = `/api/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<OrderDTO>} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulk: async (orderDTO: Array<OrderDTO>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderDTO' is not null or undefined
            assertParamExists('createBulk', 'orderDTO', orderDTO)
            const localVarPath = `/api/orders/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete2', 'id', id)
            const localVarPath = `/api/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById2', 'id', id)
            const localVarPath = `/api/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [pending] 
         * @param {string} [overdueAt] 
         * @param {string} [availableAt] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2: async (pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }

            if (overdueAt !== undefined) {
                localVarQueryParameter['overdueAt'] = (overdueAt as any instanceof Date) ?
                    (overdueAt as any).toISOString() :
                    overdueAt;
            }

            if (availableAt !== undefined) {
                localVarQueryParameter['availableAt'] = (availableAt as any instanceof Date) ?
                    (availableAt as any).toISOString() :
                    availableAt;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordDelivery: async (id: string, deliveryRecordDTO: DeliveryRecordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recordDelivery', 'id', id)
            // verify required parameter 'deliveryRecordDTO' is not null or undefined
            assertParamExists('recordDelivery', 'deliveryRecordDTO', deliveryRecordDTO)
            const localVarPath = `/api/orders/{id}/deliver`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deliveryRecordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (id: string, orderDTO: OrderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update1', 'id', id)
            // verify required parameter 'orderDTO' is not null or undefined
            assertParamExists('update1', 'orderDTO', orderDTO)
            const localVarPath = `/api/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderControllerApi - functional programming interface
 * @export
 */
export const OrderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(orderDTO: OrderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create2(orderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.create2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Array<OrderDTO>} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBulk(orderDTO: Array<OrderDTO>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBulk(orderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.createBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.delete2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.getById2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [pending] 
         * @param {string} [overdueAt] 
         * @param {string} [availableAt] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list2(pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list2(pending, overdueAt, availableAt, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.list2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordDelivery(id: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordDelivery(id, deliveryRecordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.recordDelivery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(id: string, orderDTO: OrderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(id, orderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.update1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderControllerApi - factory interface
 * @export
 */
export const OrderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(orderDTO: OrderDTO, options?: RawAxiosRequestConfig): AxiosPromise<OrderDTO> {
            return localVarFp.create2(orderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<OrderDTO>} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBulk(orderDTO: Array<OrderDTO>, options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderDTO>> {
            return localVarFp.createBulk(orderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderDTO> {
            return localVarFp.getById2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [pending] 
         * @param {string} [overdueAt] 
         * @param {string} [availableAt] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2(pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list2(pending, overdueAt, availableAt, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordDelivery(id: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.recordDelivery(id, deliveryRecordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(id: string, orderDTO: OrderDTO, options?: RawAxiosRequestConfig): AxiosPromise<OrderDTO> {
            return localVarFp.update1(id, orderDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderControllerApi - object-oriented interface
 * @export
 * @class OrderControllerApi
 * @extends {BaseAPI}
 */
export class OrderControllerApi extends BaseAPI {
    /**
     * 
     * @param {OrderDTO} orderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public create2(orderDTO: OrderDTO, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).create2(orderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<OrderDTO>} orderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public createBulk(orderDTO: Array<OrderDTO>, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).createBulk(orderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public delete2(id: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).delete2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getById2(id: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getById2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [pending] 
     * @param {string} [overdueAt] 
     * @param {string} [availableAt] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public list2(pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).list2(pending, overdueAt, availableAt, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DeliveryRecordDTO} deliveryRecordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public recordDelivery(id: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).recordDelivery(id, deliveryRecordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {OrderDTO} orderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public update1(id: string, orderDTO: OrderDTO, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).update1(id, orderDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServeRecordControllerApi - axios parameter creator
 * @export
 */
export const ServeRecordControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServeRecordDTO} serveRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (serveRecordDTO: ServeRecordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serveRecordDTO' is not null or undefined
            assertParamExists('create1', 'serveRecordDTO', serveRecordDTO)
            const localVarPath = `/api/serve-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serveRecordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete1', 'id', id)
            const localVarPath = `/api/serve-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById1', 'id', id)
            const localVarPath = `/api/serve-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [orderId] 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1: async (orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/serve-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicleId'] = vehicleId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServeRecordControllerApi - functional programming interface
 * @export
 */
export const ServeRecordControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServeRecordControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ServeRecordDTO} serveRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(serveRecordDTO: ServeRecordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(serveRecordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.create1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.getById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [orderId] 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list1(orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list1(orderId, vehicleId, startDate, endDate, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.list1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServeRecordControllerApi - factory interface
 * @export
 */
export const ServeRecordControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServeRecordControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ServeRecordDTO} serveRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(serveRecordDTO: ServeRecordDTO, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.create1(serveRecordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.getById1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [orderId] 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list1(orderId, vehicleId, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServeRecordControllerApi - object-oriented interface
 * @export
 * @class ServeRecordControllerApi
 * @extends {BaseAPI}
 */
export class ServeRecordControllerApi extends BaseAPI {
    /**
     * 
     * @param {ServeRecordDTO} serveRecordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public create1(serveRecordDTO: ServeRecordDTO, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).create1(serveRecordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public delete1(id: string, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).delete1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public getById1(id: string, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).getById1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [orderId] 
     * @param {string} [vehicleId] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public list1(orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).list1(orderId, vehicleId, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SimulationApi - axios parameter creator
 * @export
 */
export const SimulationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new simulation with the specified parameters. For WEEKLY type, end date is automatically set to one week after start date. For INFINITE, no end date is used.
         * @summary Create a new simplified simulation
         * @param {SimulationCreateDTO} simulationCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation: async (simulationCreateDTO: SimulationCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'simulationCreateDTO' is not null or undefined
            assertParamExists('createSimulation', 'simulationCreateDTO', simulationCreateDTO)
            const localVarPath = `/api/simulation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(simulationCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Crea un evento de avería para un vehículo en la simulación
         * @summary Crear avería de vehículo
         * @param {string} simulationId 
         * @param {string} vehicleId 
         * @param {IncidentCreateDTO} [incidentCreateDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVehicleBreakdown: async (simulationId: string, vehicleId: string, incidentCreateDTO?: IncidentCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'simulationId' is not null or undefined
            assertParamExists('createVehicleBreakdown', 'simulationId', simulationId)
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('createVehicleBreakdown', 'vehicleId', vehicleId)
            const localVarPath = `/api/simulation/{simulationId}/vehicle/{vehicleId}/breakdown`
                .replace(`{${"simulationId"}}`, encodeURIComponent(String(simulationId)))
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incidentCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina una simulación por su ID
         * @summary Eliminar una simulación
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a specific simulation by its ID
         * @summary Get simulation by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all active simulations
         * @summary List all simulations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/simulation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Carga un archivo de bloqueos para un año y mes específico en una simulación
         * @summary Cargar bloqueos para una simulación
         * @param {string} id 
         * @param {number} year 
         * @param {number} month 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBlockages: async (id: string, year: number, month: number, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loadBlockages', 'id', id)
            // verify required parameter 'year' is not null or undefined
            assertParamExists('loadBlockages', 'year', year)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('loadBlockages', 'month', month)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('loadBlockages', 'file', file)
            const localVarPath = `/api/simulation/{id}/load-blockages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Carga un archivo de órdenes para un año y mes específico en una simulación
         * @summary Cargar órdenes para una simulación
         * @param {string} id 
         * @param {number} year 
         * @param {number} month 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadOrders: async (id: string, year: number, month: number, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('loadOrders', 'id', id)
            // verify required parameter 'year' is not null or undefined
            assertParamExists('loadOrders', 'year', year)
            // verify required parameter 'month' is not null or undefined
            assertParamExists('loadOrders', 'month', month)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('loadOrders', 'file', file)
            const localVarPath = `/api/simulation/{id}/load-orders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pauses a running simulation
         * @summary Pause a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pauseSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replanSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('replanSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}/replan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts or resumes a paused simulation
         * @summary Start a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently stops a simulation
         * @summary Stop a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stopSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulationApi - functional programming interface
 * @export
 */
export const SimulationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SimulationApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new simulation with the specified parameters. For WEEKLY type, end date is automatically set to one week after start date. For INFINITE, no end date is used.
         * @summary Create a new simplified simulation
         * @param {SimulationCreateDTO} simulationCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSimulation(simulationCreateDTO: SimulationCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSimulation(simulationCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.createSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Crea un evento de avería para un vehículo en la simulación
         * @summary Crear avería de vehículo
         * @param {string} simulationId 
         * @param {string} vehicleId 
         * @param {IncidentCreateDTO} [incidentCreateDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVehicleBreakdown(simulationId: string, vehicleId: string, incidentCreateDTO?: IncidentCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVehicleBreakdown(simulationId, vehicleId, incidentCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.createVehicleBreakdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina una simulación por su ID
         * @summary Eliminar una simulación
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.deleteSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a specific simulation by its ID
         * @summary Get simulation by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all active simulations
         * @summary List all simulations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSimulations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: SimulationDTO; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSimulations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.listSimulations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Carga un archivo de bloqueos para un año y mes específico en una simulación
         * @summary Cargar bloqueos para una simulación
         * @param {string} id 
         * @param {number} year 
         * @param {number} month 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadBlockages(id: string, year: number, month: number, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadBlockages(id, year, month, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.loadBlockages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Carga un archivo de órdenes para un año y mes específico en una simulación
         * @summary Cargar órdenes para una simulación
         * @param {string} id 
         * @param {number} year 
         * @param {number} month 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loadOrders(id: string, year: number, month: number, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loadOrders(id, year, month, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.loadOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pauses a running simulation
         * @summary Pause a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.pauseSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replanSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replanSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.replanSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts or resumes a paused simulation
         * @summary Start a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.startSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Permanently stops a simulation
         * @summary Stop a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.stopSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SimulationApi - factory interface
 * @export
 */
export const SimulationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SimulationApiFp(configuration)
    return {
        /**
         * Creates a new simulation with the specified parameters. For WEEKLY type, end date is automatically set to one week after start date. For INFINITE, no end date is used.
         * @summary Create a new simplified simulation
         * @param {SimulationCreateDTO} simulationCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(simulationCreateDTO: SimulationCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<SimulationDTO> {
            return localVarFp.createSimulation(simulationCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Crea un evento de avería para un vehículo en la simulación
         * @summary Crear avería de vehículo
         * @param {string} simulationId 
         * @param {string} vehicleId 
         * @param {IncidentCreateDTO} [incidentCreateDTO] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVehicleBreakdown(simulationId: string, vehicleId: string, incidentCreateDTO?: IncidentCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createVehicleBreakdown(simulationId, vehicleId, incidentCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina una simulación por su ID
         * @summary Eliminar una simulación
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSimulation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a specific simulation by its ID
         * @summary Get simulation by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationDTO> {
            return localVarFp.getSimulation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all active simulations
         * @summary List all simulations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSimulations(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: SimulationDTO; }> {
            return localVarFp.listSimulations(options).then((request) => request(axios, basePath));
        },
        /**
         * Carga un archivo de bloqueos para un año y mes específico en una simulación
         * @summary Cargar bloqueos para una simulación
         * @param {string} id 
         * @param {number} year 
         * @param {number} month 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadBlockages(id: string, year: number, month: number, file: File, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.loadBlockages(id, year, month, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Carga un archivo de órdenes para un año y mes específico en una simulación
         * @summary Cargar órdenes para una simulación
         * @param {string} id 
         * @param {number} year 
         * @param {number} month 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loadOrders(id: string, year: number, month: number, file: File, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.loadOrders(id, year, month, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Pauses a running simulation
         * @summary Pause a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationDTO> {
            return localVarFp.pauseSimulation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replanSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationDTO> {
            return localVarFp.replanSimulation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts or resumes a paused simulation
         * @summary Start a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationDTO> {
            return localVarFp.startSimulation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently stops a simulation
         * @summary Stop a simulation
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationDTO> {
            return localVarFp.stopSimulation(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SimulationApi - object-oriented interface
 * @export
 * @class SimulationApi
 * @extends {BaseAPI}
 */
export class SimulationApi extends BaseAPI {
    /**
     * Creates a new simulation with the specified parameters. For WEEKLY type, end date is automatically set to one week after start date. For INFINITE, no end date is used.
     * @summary Create a new simplified simulation
     * @param {SimulationCreateDTO} simulationCreateDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public createSimulation(simulationCreateDTO: SimulationCreateDTO, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).createSimulation(simulationCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Crea un evento de avería para un vehículo en la simulación
     * @summary Crear avería de vehículo
     * @param {string} simulationId 
     * @param {string} vehicleId 
     * @param {IncidentCreateDTO} [incidentCreateDTO] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public createVehicleBreakdown(simulationId: string, vehicleId: string, incidentCreateDTO?: IncidentCreateDTO, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).createVehicleBreakdown(simulationId, vehicleId, incidentCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina una simulación por su ID
     * @summary Eliminar una simulación
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public deleteSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).deleteSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a specific simulation by its ID
     * @summary Get simulation by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all active simulations
     * @summary List all simulations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public listSimulations(options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).listSimulations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Carga un archivo de bloqueos para un año y mes específico en una simulación
     * @summary Cargar bloqueos para una simulación
     * @param {string} id 
     * @param {number} year 
     * @param {number} month 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public loadBlockages(id: string, year: number, month: number, file: File, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).loadBlockages(id, year, month, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Carga un archivo de órdenes para un año y mes específico en una simulación
     * @summary Cargar órdenes para una simulación
     * @param {string} id 
     * @param {number} year 
     * @param {number} month 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public loadOrders(id: string, year: number, month: number, file: File, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).loadOrders(id, year, month, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pauses a running simulation
     * @summary Pause a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public pauseSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).pauseSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public replanSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).replanSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts or resumes a paused simulation
     * @summary Start a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public startSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).startSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently stops a simulation
     * @summary Stop a simulation
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public stopSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).stopSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VehicleControllerApi - axios parameter creator
 * @export
 */
export const VehicleControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (vehicleDTO: VehicleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleDTO' is not null or undefined
            assertParamExists('create', 'vehicleDTO', vehicleDTO)
            const localVarPath = `/api/vehicles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vehicleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById', 'id', id)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListTypeEnum} [type] 
         * @param {ListStatusEnum} [status] 
         * @param {number} [minGlp] 
         * @param {number} [minFuel] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minGlp !== undefined) {
                localVarQueryParameter['minGlp'] = minGlp;
            }

            if (minFuel !== undefined) {
                localVarQueryParameter['minFuel'] = minFuel;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} distanceKm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveVehicle: async (id: string, distanceKm: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveVehicle', 'id', id)
            // verify required parameter 'distanceKm' is not null or undefined
            assertParamExists('moveVehicle', 'distanceKm', distanceKm)
            const localVarPath = `/api/vehicles/{id}/move`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (distanceKm !== undefined) {
                localVarQueryParameter['distanceKm'] = distanceKm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} volumeM3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refillGlp: async (id: string, volumeM3: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refillGlp', 'id', id)
            // verify required parameter 'volumeM3' is not null or undefined
            assertParamExists('refillGlp', 'volumeM3', volumeM3)
            const localVarPath = `/api/vehicles/{id}/refill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (volumeM3 !== undefined) {
                localVarQueryParameter['volumeM3'] = volumeM3;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuel: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refuel', 'id', id)
            const localVarPath = `/api/vehicles/{id}/refuel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} orderId 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveOrder: async (id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serveOrder', 'id', id)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('serveOrder', 'orderId', orderId)
            // verify required parameter 'deliveryRecordDTO' is not null or undefined
            assertParamExists('serveOrder', 'deliveryRecordDTO', deliveryRecordDTO)
            const localVarPath = `/api/vehicles/{id}/serve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deliveryRecordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, vehicleDTO: VehicleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'vehicleDTO' is not null or undefined
            assertParamExists('update', 'vehicleDTO', vehicleDTO)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vehicleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehicleControllerApi - functional programming interface
 * @export
 */
export const VehicleControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VehicleControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(vehicleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListTypeEnum} [type] 
         * @param {ListStatusEnum} [status] 
         * @param {number} [minGlp] 
         * @param {number} [minFuel] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(type, status, minGlp, minFuel, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} distanceKm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveVehicle(id: string, distanceKm: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveVehicle(id, distanceKm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.moveVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} volumeM3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refillGlp(id: string, volumeM3: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refillGlp(id, volumeM3, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.refillGlp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refuel(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refuel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.refuel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} orderId 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveOrder(id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveOrder(id, orderId, deliveryRecordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.serveOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, vehicleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VehicleControllerApi - factory interface
 * @export
 */
export const VehicleControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VehicleControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.create(vehicleDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.getById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListTypeEnum} [type] 
         * @param {ListStatusEnum} [status] 
         * @param {number} [minGlp] 
         * @param {number} [minFuel] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list(type, status, minGlp, minFuel, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} distanceKm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveVehicle(id: string, distanceKm: number, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.moveVehicle(id, distanceKm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} volumeM3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refillGlp(id: string, volumeM3: number, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.refillGlp(id, volumeM3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuel(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.refuel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} orderId 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveOrder(id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.serveOrder(id, orderId, deliveryRecordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.update(id, vehicleDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VehicleControllerApi - object-oriented interface
 * @export
 * @class VehicleControllerApi
 * @extends {BaseAPI}
 */
export class VehicleControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public _delete(id: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VehicleDTO} vehicleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public create(vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).create(vehicleDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public getById(id: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).getById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListTypeEnum} [type] 
     * @param {ListStatusEnum} [status] 
     * @param {number} [minGlp] 
     * @param {number} [minFuel] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public list(type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).list(type, status, minGlp, minFuel, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} distanceKm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public moveVehicle(id: string, distanceKm: number, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).moveVehicle(id, distanceKm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} volumeM3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public refillGlp(id: string, volumeM3: number, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).refillGlp(id, volumeM3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public refuel(id: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).refuel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} orderId 
     * @param {DeliveryRecordDTO} deliveryRecordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public serveOrder(id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).serveOrder(id, orderId, deliveryRecordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {VehicleDTO} vehicleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public update(id: string, vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).update(id, vehicleDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;
export type ListTypeEnum = typeof ListTypeEnum[keyof typeof ListTypeEnum];
/**
 * @export
 */
export const ListStatusEnum = {
    Available: 'AVAILABLE',
    Driving: 'DRIVING',
    Maintenance: 'MAINTENANCE',
    Refueling: 'REFUELING',
    Reloading: 'RELOADING',
    Serving: 'SERVING',
    Incident: 'INCIDENT',
    Idle: 'IDLE'
} as const;
export type ListStatusEnum = typeof ListStatusEnum[keyof typeof ListStatusEnum];


