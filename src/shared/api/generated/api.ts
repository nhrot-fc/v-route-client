/* tslint:disable */
/* eslint-disable */
/**
 * PLG System Management API
 * API para la gestión del sistema PLG (Propane Liquid Gas). Incluye gestión de vehículos, mantenimientos, bloqueos, incidentes y órdenes.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: plgsystem@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Blockage
 */
export interface Blockage {
    /**
     * 
     * @type {number}
     * @memberof Blockage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'endTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'linePoints'?: string;
    /**
     * 
     * @type {Array<Position>}
     * @memberof Blockage
     */
    'lines'?: Array<Position>;
}
/**
 * 
 * @export
 * @interface DeliveryRecordDTO
 */
export interface DeliveryRecordDTO {
    /**
     * 
     * @type {string}
     * @memberof DeliveryRecordDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {number}
     * @memberof DeliveryRecordDTO
     */
    'volumeM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof DeliveryRecordDTO
     */
    'serveDate'?: string;
}
/**
 * 
 * @export
 * @interface Depot
 */
export interface Depot {
    /**
     * 
     * @type {string}
     * @memberof Depot
     */
    'id'?: string;
    /**
     * 
     * @type {Position}
     * @memberof Depot
     */
    'position'?: Position;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Depot
     */
    'canRefuel'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'currentGlpM3'?: number;
}
/**
 * 
 * @export
 * @interface DepotDTO
 */
export interface DepotDTO {
    /**
     * 
     * @type {string}
     * @memberof DepotDTO
     */
    'id'?: string;
    /**
     * 
     * @type {Position}
     * @memberof DepotDTO
     */
    'position'?: Position;
    /**
     * 
     * @type {number}
     * @memberof DepotDTO
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DepotDTO
     */
    'canRefuel'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DepotDTO
     */
    'currentGlpM3'?: number;
}
/**
 * 
 * @export
 * @interface Incident
 */
export interface Incident {
    /**
     * 
     * @type {number}
     * @memberof Incident
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {Vehicle}
     * @memberof Incident
     */
    'vehicle'?: Vehicle;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'type'?: IncidentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'shift'?: IncidentShiftEnum;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'occurrenceTime'?: string;
    /**
     * 
     * @type {Position}
     * @memberof Incident
     */
    'location'?: Position;
    /**
     * 
     * @type {boolean}
     * @memberof Incident
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Incident
     */
    'transferableGlp'?: number;
}

export const IncidentTypeEnum = {
    Ti1: 'TI1',
    Ti2: 'TI2',
    Ti3: 'TI3'
} as const;

export type IncidentTypeEnum = typeof IncidentTypeEnum[keyof typeof IncidentTypeEnum];
export const IncidentShiftEnum = {
    T1: 'T1',
    T2: 'T2',
    T3: 'T3'
} as const;

export type IncidentShiftEnum = typeof IncidentShiftEnum[keyof typeof IncidentShiftEnum];

/**
 * 
 * @export
 * @interface IncidentCreateDTO
 */
export interface IncidentCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof IncidentCreateDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentCreateDTO
     */
    'type'?: IncidentCreateDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IncidentCreateDTO
     */
    'shift'?: IncidentCreateDTOShiftEnum;
    /**
     * 
     * @type {string}
     * @memberof IncidentCreateDTO
     */
    'occurrenceTime'?: string;
    /**
     * 
     * @type {Position}
     * @memberof IncidentCreateDTO
     */
    'location'?: Position;
    /**
     * 
     * @type {number}
     * @memberof IncidentCreateDTO
     */
    'transferableGlp'?: number;
}

export const IncidentCreateDTOTypeEnum = {
    Ti1: 'TI1',
    Ti2: 'TI2',
    Ti3: 'TI3'
} as const;

export type IncidentCreateDTOTypeEnum = typeof IncidentCreateDTOTypeEnum[keyof typeof IncidentCreateDTOTypeEnum];
export const IncidentCreateDTOShiftEnum = {
    T1: 'T1',
    T2: 'T2',
    T3: 'T3'
} as const;

export type IncidentCreateDTOShiftEnum = typeof IncidentCreateDTOShiftEnum[keyof typeof IncidentCreateDTOShiftEnum];

/**
 * 
 * @export
 * @interface IncidentDTO
 */
export interface IncidentDTO {
    /**
     * 
     * @type {number}
     * @memberof IncidentDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'type'?: IncidentDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'shift'?: IncidentDTOShiftEnum;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'occurrenceTime'?: string;
    /**
     * 
     * @type {Position}
     * @memberof IncidentDTO
     */
    'location'?: Position;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentDTO
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IncidentDTO
     */
    'transferableGlp'?: number;
    /**
     * 
     * @type {string}
     * @memberof IncidentDTO
     */
    'availabilityTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentDTO
     */
    'requiresReturnToDepot'?: boolean;
}

export const IncidentDTOTypeEnum = {
    Ti1: 'TI1',
    Ti2: 'TI2',
    Ti3: 'TI3'
} as const;

export type IncidentDTOTypeEnum = typeof IncidentDTOTypeEnum[keyof typeof IncidentDTOTypeEnum];
export const IncidentDTOShiftEnum = {
    T1: 'T1',
    T2: 'T2',
    T3: 'T3'
} as const;

export type IncidentDTOShiftEnum = typeof IncidentDTOShiftEnum[keyof typeof IncidentDTOShiftEnum];

/**
 * 
 * @export
 * @interface Maintenance
 */
export interface Maintenance {
    /**
     * 
     * @type {number}
     * @memberof Maintenance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {Vehicle}
     * @memberof Maintenance
     */
    'vehicle'?: Vehicle;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'assignedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'realStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'realEnd'?: string;
    /**
     * 
     * @type {number}
     * @memberof Maintenance
     */
    'durationHours'?: number;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @interface MaintenanceCreateDTO
 */
export interface MaintenanceCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof MaintenanceCreateDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceCreateDTO
     */
    'assignedDate'?: string;
}
/**
 * 
 * @export
 * @interface MaintenanceDTO
 */
export interface MaintenanceDTO {
    /**
     * 
     * @type {number}
     * @memberof MaintenanceDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'assignedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'realStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof MaintenanceDTO
     */
    'realEnd'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MaintenanceDTO
     */
    'active'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MaintenanceDTO
     */
    'durationHours'?: number;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'arriveTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'dueTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'glpRequestM3'?: number;
    /**
     * 
     * @type {Position}
     * @memberof Order
     */
    'position'?: Position;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'remainingGlpM3'?: number;
    /**
     * 
     * @type {Array<ServeRecord>}
     * @memberof Order
     */
    'serveRecords'?: Array<ServeRecord>;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'delivered'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderDTO
 */
export interface OrderDTO {
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'arriveTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDTO
     */
    'dueTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'glpRequestM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDTO
     */
    'remainingGlpM3'?: number;
    /**
     * 
     * @type {Position}
     * @memberof OrderDTO
     */
    'position'?: Position;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDTO
     */
    'delivered'?: boolean;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface ServeRecord
 */
export interface ServeRecord {
    /**
     * 
     * @type {number}
     * @memberof ServeRecord
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServeRecord
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {Vehicle}
     * @memberof ServeRecord
     */
    'vehicle'?: Vehicle;
    /**
     * 
     * @type {string}
     * @memberof ServeRecord
     */
    'orderId'?: string;
    /**
     * 
     * @type {Order}
     * @memberof ServeRecord
     */
    'order'?: Order;
    /**
     * 
     * @type {number}
     * @memberof ServeRecord
     */
    'volumeM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServeRecord
     */
    'serveDate'?: string;
}
/**
 * 
 * @export
 * @interface ServeRecordDTO
 */
export interface ServeRecordDTO {
    /**
     * 
     * @type {number}
     * @memberof ServeRecordDTO
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServeRecordDTO
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ServeRecordDTO
     */
    'orderId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ServeRecordDTO
     */
    'volumeM3'?: number;
    /**
     * 
     * @type {string}
     * @memberof ServeRecordDTO
     */
    'serveDate'?: string;
}
/**
 * 
 * @export
 * @interface SimulationReportDTO
 */
export interface SimulationReportDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationReportDTO
     */
    'simulationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationReportDTO
     */
    'simulationType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationReportDTO
     */
    'simulationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationReportDTO
     */
    'startDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationReportDTO
     */
    'endDateTime'?: string;
    /**
     * 
     * @type {SimulationReportDTOTotalDuration}
     * @memberof SimulationReportDTO
     */
    'totalDuration'?: SimulationReportDTOTotalDuration;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'realExecutionTimeMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'deliveredOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'pendingOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'lateDeliveries'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'onTimeDeliveryRate'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalDistanceTraveled'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalFuelConsumed'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'averageFuelEfficiency'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalVehicleBreakdowns'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalMaintenanceEvents'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalBlockages'?: number;
    /**
     * 
     * @type {SimulationReportDTOTotalDuration}
     * @memberof SimulationReportDTO
     */
    'totalBlockageDuration'?: SimulationReportDTOTotalDuration;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalReplans'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'averagePlanningTimeMillis'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'totalVehicles'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTO
     */
    'averageVehicleUtilization'?: number;
}
/**
 * 
 * @export
 * @interface SimulationReportDTOTotalDuration
 */
export interface SimulationReportDTOTotalDuration {
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTOTotalDuration
     */
    'seconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimulationReportDTOTotalDuration
     */
    'zero'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SimulationReportDTOTotalDuration
     */
    'nano'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimulationReportDTOTotalDuration
     */
    'negative'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimulationReportDTOTotalDuration
     */
    'positive'?: boolean;
    /**
     * 
     * @type {Array<SimulationReportDTOTotalDurationUnitsInner>}
     * @memberof SimulationReportDTOTotalDuration
     */
    'units'?: Array<SimulationReportDTOTotalDurationUnitsInner>;
}
/**
 * 
 * @export
 * @interface SimulationReportDTOTotalDurationUnitsInner
 */
export interface SimulationReportDTOTotalDurationUnitsInner {
    /**
     * 
     * @type {boolean}
     * @memberof SimulationReportDTOTotalDurationUnitsInner
     */
    'durationEstimated'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimulationReportDTOTotalDurationUnitsInner
     */
    'timeBased'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimulationReportDTOTotalDurationUnitsInner
     */
    'dateBased'?: boolean;
}
/**
 * 
 * @export
 * @interface SimulationStateDTO
 */
export interface SimulationStateDTO {
    /**
     * 
     * @type {string}
     * @memberof SimulationStateDTO
     */
    'simulationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SimulationStateDTO
     */
    'currentTime'?: string;
    /**
     * 
     * @type {Array<VehicleDTO>}
     * @memberof SimulationStateDTO
     */
    'vehicles'?: Array<VehicleDTO>;
    /**
     * 
     * @type {DepotDTO}
     * @memberof SimulationStateDTO
     */
    'mainDepot'?: DepotDTO;
    /**
     * 
     * @type {Array<DepotDTO>}
     * @memberof SimulationStateDTO
     */
    'auxDepots'?: Array<DepotDTO>;
    /**
     * 
     * @type {Array<OrderDTO>}
     * @memberof SimulationStateDTO
     */
    'orders'?: Array<OrderDTO>;
    /**
     * 
     * @type {Array<Blockage>}
     * @memberof SimulationStateDTO
     */
    'activeBlockages'?: Array<Blockage>;
    /**
     * 
     * @type {Array<Incident>}
     * @memberof SimulationStateDTO
     */
    'activeIncidents'?: Array<Incident>;
    /**
     * 
     * @type {Array<Maintenance>}
     * @memberof SimulationStateDTO
     */
    'scheduledMaintenances'?: Array<Maintenance>;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'pendingOrdersCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'deliveredOrdersCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'overdueOrdersCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof SimulationStateDTO
     */
    'availableVehiclesCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SimulationStateDTO
     */
    'running'?: boolean;
}
/**
 * 
 * @export
 * @interface Vehicle
 */
export interface Vehicle {
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'type'?: VehicleTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'fuelCapacityGal'?: number;
    /**
     * 
     * @type {Position}
     * @memberof Vehicle
     */
    'currentPosition'?: Position;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentGlpM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentFuelGal'?: number;
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'status'?: VehicleStatusEnum;
    /**
     * 
     * @type {Array<Incident>}
     * @memberof Vehicle
     */
    'incidents'?: Array<Incident>;
    /**
     * 
     * @type {Array<ServeRecord>}
     * @memberof Vehicle
     */
    'serveRecords'?: Array<ServeRecord>;
    /**
     * 
     * @type {Array<Maintenance>}
     * @memberof Vehicle
     */
    'maintenances'?: Array<Maintenance>;
}

export const VehicleTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;

export type VehicleTypeEnum = typeof VehicleTypeEnum[keyof typeof VehicleTypeEnum];
export const VehicleStatusEnum = {
    Available: 'AVAILABLE',
    Driving: 'DRIVING',
    Maintenance: 'MAINTENANCE',
    Refueling: 'REFUELING',
    Reloading: 'RELOADING',
    Serving: 'SERVING',
    Incident: 'INCIDENT',
    Idle: 'IDLE'
} as const;

export type VehicleStatusEnum = typeof VehicleStatusEnum[keyof typeof VehicleStatusEnum];

/**
 * 
 * @export
 * @interface VehicleDTO
 */
export interface VehicleDTO {
    /**
     * 
     * @type {string}
     * @memberof VehicleDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehicleDTO
     */
    'type'?: VehicleDTOTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'glpCapacityM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'fuelCapacityGal'?: number;
    /**
     * 
     * @type {Position}
     * @memberof VehicleDTO
     */
    'currentPosition'?: Position;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'currentGlpM3'?: number;
    /**
     * 
     * @type {number}
     * @memberof VehicleDTO
     */
    'currentFuelGal'?: number;
    /**
     * 
     * @type {string}
     * @memberof VehicleDTO
     */
    'status'?: VehicleDTOStatusEnum;
}

export const VehicleDTOTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;

export type VehicleDTOTypeEnum = typeof VehicleDTOTypeEnum[keyof typeof VehicleDTOTypeEnum];
export const VehicleDTOStatusEnum = {
    Available: 'AVAILABLE',
    Driving: 'DRIVING',
    Maintenance: 'MAINTENANCE',
    Refueling: 'REFUELING',
    Reloading: 'RELOADING',
    Serving: 'SERVING',
    Incident: 'INCIDENT',
    Idle: 'IDLE'
} as const;

export type VehicleDTOStatusEnum = typeof VehicleDTOStatusEnum[keyof typeof VehicleDTOStatusEnum];


/**
 * BlockageControllerApi - axios parameter creator
 * @export
 */
export const BlockageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5: async (blockage: Blockage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockage' is not null or undefined
            assertParamExists('create5', 'blockage', blockage)
            const localVarPath = `/api/blockages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete4', 'id', id)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById5: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById5', 'id', id)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [activeAt] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list5: async (activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/blockages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeAt !== undefined) {
                localVarQueryParameter['activeAt'] = (activeAt as any instanceof Date) ?
                    (activeAt as any).toISOString() :
                    activeAt;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['startTime'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['endTime'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3: async (id: number, blockage: Blockage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update3', 'id', id)
            // verify required parameter 'blockage' is not null or undefined
            assertParamExists('update3', 'blockage', blockage)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockageControllerApi - functional programming interface
 * @export
 */
export const BlockageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create5(blockage: Blockage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create5(blockage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.create5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete4(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete4(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.delete4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById5(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById5(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.getById5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [activeAt] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list5(activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list5(activeAt, startTime, endTime, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.list5']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3(id: number, blockage: Blockage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update3(id, blockage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockageControllerApi.update3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlockageControllerApi - factory interface
 * @export
 */
export const BlockageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockageControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create5(blockage: Blockage, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.create5(blockage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById5(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.getById5(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [activeAt] 
         * @param {string} [startTime] 
         * @param {string} [endTime] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list5(activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list5(activeAt, startTime, endTime, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3(id: number, blockage: Blockage, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.update3(id, blockage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockageControllerApi - object-oriented interface
 * @export
 * @class BlockageControllerApi
 * @extends {BaseAPI}
 */
export class BlockageControllerApi extends BaseAPI {
    /**
     * 
     * @param {Blockage} blockage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public create5(blockage: Blockage, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).create5(blockage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public delete4(id: number, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).delete4(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public getById5(id: number, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).getById5(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [activeAt] 
     * @param {string} [startTime] 
     * @param {string} [endTime] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public list5(activeAt?: string, startTime?: string, endTime?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).list5(activeAt, startTime, endTime, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Blockage} blockage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockageControllerApi
     */
    public update3(id: number, blockage: Blockage, options?: RawAxiosRequestConfig) {
        return BlockageControllerApiFp(this.configuration).update3(id, blockage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardOverview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/system-health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrgentOrders: async (hoursAhead?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/urgent-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hoursAhead !== undefined) {
                localVarQueryParameter['hoursAhead'] = hoursAhead;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleStatusBreakdown: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/vehicle-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardOverview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardOverview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboardOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getSystemHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrgentOrders(hoursAhead, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getUrgentOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehicleStatusBreakdown(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehicleStatusBreakdown(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getVehicleStatusBreakdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardOverview(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDashboardOverview(options).then((request) => request(axios, basePath));
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSystemHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.getUrgentOrders(hoursAhead, options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleStatusBreakdown(options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.getVehicleStatusBreakdown(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
     * @summary Obtener resumen del dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardOverview(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardOverview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
     * @summary Obtener salud del sistema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getSystemHealth(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getSystemHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve las órdenes que vencen dentro del plazo especificado
     * @summary Obtener órdenes urgentes
     * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getUrgentOrders(hoursAhead, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve un desglose de vehículos agrupados por su estado operativo
     * @summary Obtener estado de vehículos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getVehicleStatusBreakdown(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getVehicleStatusBreakdown(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepotControllerApi - axios parameter creator
 * @export
 */
export const DepotControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (depot: Depot, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'depot' is not null or undefined
            assertParamExists('create4', 'depot', depot)
            const localVarPath = `/api/depots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete3', 'id', id)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById4', 'id', id)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [canRefuel] 
         * @param {number} [minGlpCapacity] 
         * @param {number} [minCurrentGlp] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list4: async (canRefuel?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/depots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (canRefuel !== undefined) {
                localVarQueryParameter['canRefuel'] = canRefuel;
            }

            if (minGlpCapacity !== undefined) {
                localVarQueryParameter['minGlpCapacity'] = minGlpCapacity;
            }

            if (minCurrentGlp !== undefined) {
                localVarQueryParameter['minCurrentGlp'] = minCurrentGlp;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2: async (id: string, depot: Depot, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update2', 'id', id)
            // verify required parameter 'depot' is not null or undefined
            assertParamExists('update2', 'depot', depot)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepotControllerApi - functional programming interface
 * @export
 */
export const DepotControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepotControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(depot: Depot, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create4(depot, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.create4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.delete3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById4(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById4(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.getById4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [canRefuel] 
         * @param {number} [minGlpCapacity] 
         * @param {number} [minCurrentGlp] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list4(canRefuel?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list4(canRefuel, minGlpCapacity, minCurrentGlp, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.list4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update2(id: string, depot: Depot, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update2(id, depot, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotControllerApi.update2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepotControllerApi - factory interface
 * @export
 */
export const DepotControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepotControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(depot: Depot, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.create4(depot, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById4(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.getById4(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [canRefuel] 
         * @param {number} [minGlpCapacity] 
         * @param {number} [minCurrentGlp] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list4(canRefuel?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list4(canRefuel, minGlpCapacity, minCurrentGlp, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update2(id: string, depot: Depot, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.update2(id, depot, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepotControllerApi - object-oriented interface
 * @export
 * @class DepotControllerApi
 * @extends {BaseAPI}
 */
export class DepotControllerApi extends BaseAPI {
    /**
     * 
     * @param {Depot} depot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public create4(depot: Depot, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).create4(depot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public delete3(id: string, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).delete3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public getById4(id: string, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).getById4(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [canRefuel] 
     * @param {number} [minGlpCapacity] 
     * @param {number} [minCurrentGlp] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public list4(canRefuel?: boolean, minGlpCapacity?: number, minCurrentGlp?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).list4(canRefuel, minGlpCapacity, minCurrentGlp, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {Depot} depot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotControllerApi
     */
    public update2(id: string, depot: Depot, options?: RawAxiosRequestConfig) {
        return DepotControllerApiFp(this.configuration).update2(id, depot, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IncidentControllerApi - axios parameter creator
 * @export
 */
export const IncidentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {IncidentCreateDTO} incidentCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (incidentCreateDTO: IncidentCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incidentCreateDTO' is not null or undefined
            assertParamExists('create3', 'incidentCreateDTO', incidentCreateDTO)
            const localVarPath = `/api/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incidentCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById3', 'id', id)
            const localVarPath = `/api/incidents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [resolved] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list3: async (vehicleId?: string, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicleId'] = vehicleId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (resolved !== undefined) {
                localVarQueryParameter['resolved'] = resolved;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIncident: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resolveIncident', 'id', id)
            const localVarPath = `/api/incidents/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncidentControllerApi - functional programming interface
 * @export
 */
export const IncidentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncidentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {IncidentCreateDTO} incidentCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(incidentCreateDTO: IncidentCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create3(incidentCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.create3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById3(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById3(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.getById3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [resolved] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list3(vehicleId?: string, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list3(vehicleId, startDate, endDate, resolved, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.list3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveIncident(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IncidentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveIncident(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentControllerApi.resolveIncident']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IncidentControllerApi - factory interface
 * @export
 */
export const IncidentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncidentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {IncidentCreateDTO} incidentCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(incidentCreateDTO: IncidentCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<IncidentDTO> {
            return localVarFp.create3(incidentCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(id: number, options?: RawAxiosRequestConfig): AxiosPromise<IncidentDTO> {
            return localVarFp.getById3(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [resolved] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list3(vehicleId?: string, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list3(vehicleId, startDate, endDate, resolved, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveIncident(id: number, options?: RawAxiosRequestConfig): AxiosPromise<IncidentDTO> {
            return localVarFp.resolveIncident(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncidentControllerApi - object-oriented interface
 * @export
 * @class IncidentControllerApi
 * @extends {BaseAPI}
 */
export class IncidentControllerApi extends BaseAPI {
    /**
     * 
     * @param {IncidentCreateDTO} incidentCreateDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public create3(incidentCreateDTO: IncidentCreateDTO, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).create3(incidentCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public getById3(id: number, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).getById3(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [vehicleId] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [resolved] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public list3(vehicleId?: string, startDate?: string, endDate?: string, resolved?: boolean, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).list3(vehicleId, startDate, endDate, resolved, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentControllerApi
     */
    public resolveIncident(id: number, options?: RawAxiosRequestConfig) {
        return IncidentControllerApiFp(this.configuration).resolveIncident(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MaintenanceControllerApi - axios parameter creator
 * @export
 */
export const MaintenanceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaintenance: async (maintenanceCreateDTO: MaintenanceCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maintenanceCreateDTO' is not null or undefined
            assertParamExists('createMaintenance', 'maintenanceCreateDTO', maintenanceCreateDTO)
            const localVarPath = `/api/maintenances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(maintenanceCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaintenanceById', 'id', id)
            const localVarPath = `/api/maintenances/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveMaintenances: async (paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/maintenances/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [date] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMaintenances: async (vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/maintenances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicleId'] = vehicleId;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaintenanceControllerApi - functional programming interface
 * @export
 */
export const MaintenanceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintenanceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMaintenance(maintenanceCreateDTO: MaintenanceCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMaintenance(maintenanceCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.createMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MaintenanceDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.getMaintenanceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listActiveMaintenances(paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listActiveMaintenances(paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.listActiveMaintenances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [date] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMaintenances(vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMaintenances(vehicleId, date, startDate, endDate, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceControllerApi.listMaintenances']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaintenanceControllerApi - factory interface
 * @export
 */
export const MaintenanceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaintenanceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaintenance(maintenanceCreateDTO: MaintenanceCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceDTO> {
            return localVarFp.createMaintenance(maintenanceCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MaintenanceDTO> {
            return localVarFp.getMaintenanceById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listActiveMaintenances(paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listActiveMaintenances(paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [vehicleId] 
         * @param {string} [date] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMaintenances(vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listMaintenances(vehicleId, date, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaintenanceControllerApi - object-oriented interface
 * @export
 * @class MaintenanceControllerApi
 * @extends {BaseAPI}
 */
export class MaintenanceControllerApi extends BaseAPI {
    /**
     * 
     * @param {MaintenanceCreateDTO} maintenanceCreateDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public createMaintenance(maintenanceCreateDTO: MaintenanceCreateDTO, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).createMaintenance(maintenanceCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public getMaintenanceById(id: number, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).getMaintenanceById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public listActiveMaintenances(paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).listActiveMaintenances(paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [vehicleId] 
     * @param {string} [date] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceControllerApi
     */
    public listMaintenances(vehicleId?: string, date?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return MaintenanceControllerApiFp(this.configuration).listMaintenances(vehicleId, date, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderControllerApi - axios parameter creator
 * @export
 */
export const OrderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (orderDTO: OrderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderDTO' is not null or undefined
            assertParamExists('create2', 'orderDTO', orderDTO)
            const localVarPath = `/api/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete2', 'id', id)
            const localVarPath = `/api/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById2', 'id', id)
            const localVarPath = `/api/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [pending] 
         * @param {string} [overdueAt] 
         * @param {string} [availableAt] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2: async (pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pending !== undefined) {
                localVarQueryParameter['pending'] = pending;
            }

            if (overdueAt !== undefined) {
                localVarQueryParameter['overdueAt'] = (overdueAt as any instanceof Date) ?
                    (overdueAt as any).toISOString() :
                    overdueAt;
            }

            if (availableAt !== undefined) {
                localVarQueryParameter['availableAt'] = (availableAt as any instanceof Date) ?
                    (availableAt as any).toISOString() :
                    availableAt;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordDelivery: async (id: string, deliveryRecordDTO: DeliveryRecordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('recordDelivery', 'id', id)
            // verify required parameter 'deliveryRecordDTO' is not null or undefined
            assertParamExists('recordDelivery', 'deliveryRecordDTO', deliveryRecordDTO)
            const localVarPath = `/api/orders/{id}/deliver`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deliveryRecordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (id: string, orderDTO: OrderDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update1', 'id', id)
            // verify required parameter 'orderDTO' is not null or undefined
            assertParamExists('update1', 'orderDTO', orderDTO)
            const localVarPath = `/api/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderControllerApi - functional programming interface
 * @export
 */
export const OrderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(orderDTO: OrderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create2(orderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.create2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.delete2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.getById2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {boolean} [pending] 
         * @param {string} [overdueAt] 
         * @param {string} [availableAt] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list2(pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list2(pending, overdueAt, availableAt, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.list2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordDelivery(id: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordDelivery(id, deliveryRecordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.recordDelivery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(id: string, orderDTO: OrderDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(id, orderDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderControllerApi.update1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderControllerApi - factory interface
 * @export
 */
export const OrderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(orderDTO: OrderDTO, options?: RawAxiosRequestConfig): AxiosPromise<OrderDTO> {
            return localVarFp.create2(orderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(id: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderDTO> {
            return localVarFp.getById2(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [pending] 
         * @param {string} [overdueAt] 
         * @param {string} [availableAt] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list2(pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list2(pending, overdueAt, availableAt, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordDelivery(id: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.recordDelivery(id, deliveryRecordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {OrderDTO} orderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(id: string, orderDTO: OrderDTO, options?: RawAxiosRequestConfig): AxiosPromise<OrderDTO> {
            return localVarFp.update1(id, orderDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderControllerApi - object-oriented interface
 * @export
 * @class OrderControllerApi
 * @extends {BaseAPI}
 */
export class OrderControllerApi extends BaseAPI {
    /**
     * 
     * @param {OrderDTO} orderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public create2(orderDTO: OrderDTO, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).create2(orderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public delete2(id: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).delete2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public getById2(id: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).getById2(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [pending] 
     * @param {string} [overdueAt] 
     * @param {string} [availableAt] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public list2(pending?: boolean, overdueAt?: string, availableAt?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).list2(pending, overdueAt, availableAt, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DeliveryRecordDTO} deliveryRecordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public recordDelivery(id: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).recordDelivery(id, deliveryRecordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {OrderDTO} orderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderControllerApi
     */
    public update1(id: string, orderDTO: OrderDTO, options?: RawAxiosRequestConfig) {
        return OrderControllerApiFp(this.configuration).update1(id, orderDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServeRecordControllerApi - axios parameter creator
 * @export
 */
export const ServeRecordControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServeRecordDTO} serveRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (serveRecordDTO: ServeRecordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serveRecordDTO' is not null or undefined
            assertParamExists('create1', 'serveRecordDTO', serveRecordDTO)
            const localVarPath = `/api/serve-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serveRecordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete1', 'id', id)
            const localVarPath = `/api/serve-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById1', 'id', id)
            const localVarPath = `/api/serve-records/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [orderId] 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1: async (orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/serve-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicleId'] = vehicleId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServeRecordControllerApi - functional programming interface
 * @export
 */
export const ServeRecordControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServeRecordControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ServeRecordDTO} serveRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(serveRecordDTO: ServeRecordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(serveRecordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.create1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById1(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.getById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [orderId] 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list1(orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list1(orderId, vehicleId, startDate, endDate, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServeRecordControllerApi.list1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServeRecordControllerApi - factory interface
 * @export
 */
export const ServeRecordControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServeRecordControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ServeRecordDTO} serveRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(serveRecordDTO: ServeRecordDTO, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.create1(serveRecordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.getById1(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [orderId] 
         * @param {string} [vehicleId] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list1(orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list1(orderId, vehicleId, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServeRecordControllerApi - object-oriented interface
 * @export
 * @class ServeRecordControllerApi
 * @extends {BaseAPI}
 */
export class ServeRecordControllerApi extends BaseAPI {
    /**
     * 
     * @param {ServeRecordDTO} serveRecordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public create1(serveRecordDTO: ServeRecordDTO, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).create1(serveRecordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public delete1(id: number, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).delete1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public getById1(id: number, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).getById1(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [orderId] 
     * @param {string} [vehicleId] 
     * @param {string} [startDate] 
     * @param {string} [endDate] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServeRecordControllerApi
     */
    public list1(orderId?: string, vehicleId?: string, startDate?: string, endDate?: string, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return ServeRecordControllerApiFp(this.configuration).list1(orderId, vehicleId, startDate, endDate, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SimulationApi - axios parameter creator
 * @export
 */
export const SimulationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Crea una nueva instancia de simulación según el tipo especificado
         * @summary Crear nueva simulación
         * @param {string} simulationType 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [startDate] 
         * @param {string} [dataSource] 
         * @param {number} [durationDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation: async (simulationType: string, name?: string, description?: string, startDate?: string, dataSource?: string, durationDays?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'simulationType' is not null or undefined
            assertParamExists('createSimulation', 'simulationType', simulationType)
            const localVarPath = `/api/simulation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (simulationType !== undefined) {
                localVarQueryParameter['simulationType'] = simulationType;
            }

            if (dataSource !== undefined) {
                localVarQueryParameter['dataSource'] = dataSource;
            }

            if (durationDays !== undefined) {
                localVarQueryParameter['durationDays'] = durationDays;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina una simulación existente
         * @summary Eliminar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene todos los reportes de simulaciones finalizadas
         * @summary Listar todos los reportes de simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReports: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/simulation/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene una lista de todas las simulaciones disponibles
         * @summary Listar todas las simulaciones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSimulations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/simulation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene la lista de bloqueos activos en la simulación
         * @summary Listar bloqueos
         * @param {string} id ID de la simulación
         * @param {boolean} [activeOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockages: async (id: string, activeOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlockages', 'id', id)
            const localVarPath = `/api/simulation/{id}/blockages`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (activeOnly !== undefined) {
                localVarQueryParameter['activeOnly'] = activeOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene información detallada del entorno de simulación
         * @summary Obtener detalles del entorno
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEnvironment', 'id', id)
            const localVarPath = `/api/simulation/{id}/environment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene la lista de órdenes en la simulación
         * @summary Listar órdenes
         * @param {string} id ID de la simulación
         * @param {boolean} [pendingOnly] 
         * @param {boolean} [overdueOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (id: string, pendingOnly?: boolean, overdueOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrders', 'id', id)
            const localVarPath = `/api/simulation/{id}/orders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pendingOnly !== undefined) {
                localVarQueryParameter['pendingOnly'] = pendingOnly;
            }

            if (overdueOnly !== undefined) {
                localVarQueryParameter['overdueOnly'] = overdueOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene el reporte de una simulación finalizada
         * @summary Obtener reporte de simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationReport: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSimulationReport', 'id', id)
            const localVarPath = `/api/simulation/{id}/report`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene el estado actual de una simulación específica
         * @summary Obtener estado de una simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationStatus: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSimulationStatus', 'id', id)
            const localVarPath = `/api/simulation/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Obtiene la lista de vehículos en la simulación
         * @summary Listar vehículos
         * @param {string} id ID de la simulación
         * @param {GetVehiclesStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicles: async (id: string, status?: GetVehiclesStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVehicles', 'id', id)
            const localVarPath = `/api/simulation/{id}/vehicles`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pausa la ejecución de una simulación
         * @summary Pausar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pauseSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}/pause`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simula la reparación de un vehículo averiado
         * @summary Reparar vehículo
         * @param {string} id ID de la simulación
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairVehicle: async (id: string, vehicleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('repairVehicle', 'id', id)
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('repairVehicle', 'vehicleId', vehicleId)
            const localVarPath = `/api/simulation/{id}/vehicle/{vehicleId}/repair`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ajusta la velocidad de ejecución de la simulación
         * @summary Ajustar velocidad de simulación
         * @param {string} id ID de la simulación
         * @param {number} speedFactor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimulationSpeed: async (id: string, speedFactor: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setSimulationSpeed', 'id', id)
            // verify required parameter 'speedFactor' is not null or undefined
            assertParamExists('setSimulationSpeed', 'speedFactor', speedFactor)
            const localVarPath = `/api/simulation/{id}/speed`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (speedFactor !== undefined) {
                localVarQueryParameter['speedFactor'] = speedFactor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Simula una avería en un vehículo específico
         * @summary Simular avería de vehículo
         * @param {string} id ID de la simulación
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateVehicleBreakdown: async (id: string, vehicleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('simulateVehicleBreakdown', 'id', id)
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('simulateVehicleBreakdown', 'vehicleId', vehicleId)
            const localVarPath = `/api/simulation/{id}/vehicle/{vehicleId}/breakdown`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inicia o reanuda la ejecución de una simulación
         * @summary Iniciar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSimulation: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('startSimulation', 'id', id)
            const localVarPath = `/api/simulation/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimulationApi - functional programming interface
 * @export
 */
export const SimulationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SimulationApiAxiosParamCreator(configuration)
    return {
        /**
         * Crea una nueva instancia de simulación según el tipo especificado
         * @summary Crear nueva simulación
         * @param {string} simulationType 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [startDate] 
         * @param {string} [dataSource] 
         * @param {number} [durationDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSimulation(simulationType: string, name?: string, description?: string, startDate?: string, dataSource?: string, durationDays?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSimulation(simulationType, name, description, startDate, dataSource, durationDays, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.createSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina una simulación existente
         * @summary Eliminar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.deleteSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene todos los reportes de simulaciones finalizadas
         * @summary Listar todos los reportes de simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllReports(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SimulationReportDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllReports(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getAllReports']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene una lista de todas las simulaciones disponibles
         * @summary Listar todas las simulaciones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSimulations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: object; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSimulations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getAllSimulations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene la lista de bloqueos activos en la simulación
         * @summary Listar bloqueos
         * @param {string} id ID de la simulación
         * @param {boolean} [activeOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockages(id: string, activeOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Blockage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockages(id, activeOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getBlockages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene información detallada del entorno de simulación
         * @summary Obtener detalles del entorno
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironment(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationStateDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironment(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getEnvironment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene la lista de órdenes en la simulación
         * @summary Listar órdenes
         * @param {string} id ID de la simulación
         * @param {boolean} [pendingOnly] 
         * @param {boolean} [overdueOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(id: string, pendingOnly?: boolean, overdueOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(id, pendingOnly, overdueOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene el reporte de una simulación finalizada
         * @summary Obtener reporte de simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimulationReport(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationReportDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimulationReport(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getSimulationReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene el estado actual de una simulación específica
         * @summary Obtener estado de una simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimulationStatus(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimulationStateDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimulationStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getSimulationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Obtiene la lista de vehículos en la simulación
         * @summary Listar vehículos
         * @param {string} id ID de la simulación
         * @param {GetVehiclesStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehicles(id: string, status?: GetVehiclesStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vehicle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehicles(id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.getVehicles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pausa la ejecución de una simulación
         * @summary Pausar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.pauseSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simula la reparación de un vehículo averiado
         * @summary Reparar vehículo
         * @param {string} id ID de la simulación
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repairVehicle(id: string, vehicleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.repairVehicle(id, vehicleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.repairVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Ajusta la velocidad de ejecución de la simulación
         * @summary Ajustar velocidad de simulación
         * @param {string} id ID de la simulación
         * @param {number} speedFactor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setSimulationSpeed(id: string, speedFactor: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setSimulationSpeed(id, speedFactor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.setSimulationSpeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Simula una avería en un vehículo específico
         * @summary Simular avería de vehículo
         * @param {string} id ID de la simulación
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async simulateVehicleBreakdown(id: string, vehicleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.simulateVehicleBreakdown(id, vehicleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.simulateVehicleBreakdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Inicia o reanuda la ejecución de una simulación
         * @summary Iniciar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startSimulation(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startSimulation(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SimulationApi.startSimulation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SimulationApi - factory interface
 * @export
 */
export const SimulationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SimulationApiFp(configuration)
    return {
        /**
         * Crea una nueva instancia de simulación según el tipo especificado
         * @summary Crear nueva simulación
         * @param {string} simulationType 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [startDate] 
         * @param {string} [dataSource] 
         * @param {number} [durationDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimulation(simulationType: string, name?: string, description?: string, startDate?: string, dataSource?: string, durationDays?: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.createSimulation(simulationType, name, description, startDate, dataSource, durationDays, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina una simulación existente
         * @summary Eliminar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSimulation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene todos los reportes de simulaciones finalizadas
         * @summary Listar todos los reportes de simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllReports(options?: RawAxiosRequestConfig): AxiosPromise<Array<SimulationReportDTO>> {
            return localVarFp.getAllReports(options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene una lista de todas las simulaciones disponibles
         * @summary Listar todas las simulaciones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSimulations(options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: object; }>> {
            return localVarFp.getAllSimulations(options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene la lista de bloqueos activos en la simulación
         * @summary Listar bloqueos
         * @param {string} id ID de la simulación
         * @param {boolean} [activeOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockages(id: string, activeOnly?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Blockage>> {
            return localVarFp.getBlockages(id, activeOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene información detallada del entorno de simulación
         * @summary Obtener detalles del entorno
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironment(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationStateDTO> {
            return localVarFp.getEnvironment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene la lista de órdenes en la simulación
         * @summary Listar órdenes
         * @param {string} id ID de la simulación
         * @param {boolean} [pendingOnly] 
         * @param {boolean} [overdueOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(id: string, pendingOnly?: boolean, overdueOnly?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getOrders(id, pendingOnly, overdueOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene el reporte de una simulación finalizada
         * @summary Obtener reporte de simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationReport(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationReportDTO> {
            return localVarFp.getSimulationReport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene el estado actual de una simulación específica
         * @summary Obtener estado de una simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulationStatus(id: string, options?: RawAxiosRequestConfig): AxiosPromise<SimulationStateDTO> {
            return localVarFp.getSimulationStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Obtiene la lista de vehículos en la simulación
         * @summary Listar vehículos
         * @param {string} id ID de la simulación
         * @param {GetVehiclesStatusEnum} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicles(id: string, status?: GetVehiclesStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Vehicle>> {
            return localVarFp.getVehicles(id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Pausa la ejecución de una simulación
         * @summary Pausar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.pauseSimulation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Simula la reparación de un vehículo averiado
         * @summary Reparar vehículo
         * @param {string} id ID de la simulación
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairVehicle(id: string, vehicleId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.repairVehicle(id, vehicleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Ajusta la velocidad de ejecución de la simulación
         * @summary Ajustar velocidad de simulación
         * @param {string} id ID de la simulación
         * @param {number} speedFactor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setSimulationSpeed(id: string, speedFactor: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.setSimulationSpeed(id, speedFactor, options).then((request) => request(axios, basePath));
        },
        /**
         * Simula una avería en un vehículo específico
         * @summary Simular avería de vehículo
         * @param {string} id ID de la simulación
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        simulateVehicleBreakdown(id: string, vehicleId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.simulateVehicleBreakdown(id, vehicleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Inicia o reanuda la ejecución de una simulación
         * @summary Iniciar simulación
         * @param {string} id ID de la simulación
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startSimulation(id: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.startSimulation(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SimulationApi - object-oriented interface
 * @export
 * @class SimulationApi
 * @extends {BaseAPI}
 */
export class SimulationApi extends BaseAPI {
    /**
     * Crea una nueva instancia de simulación según el tipo especificado
     * @summary Crear nueva simulación
     * @param {string} simulationType 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [startDate] 
     * @param {string} [dataSource] 
     * @param {number} [durationDays] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public createSimulation(simulationType: string, name?: string, description?: string, startDate?: string, dataSource?: string, durationDays?: number, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).createSimulation(simulationType, name, description, startDate, dataSource, durationDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina una simulación existente
     * @summary Eliminar simulación
     * @param {string} id ID de la simulación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public deleteSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).deleteSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene todos los reportes de simulaciones finalizadas
     * @summary Listar todos los reportes de simulación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getAllReports(options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getAllReports(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene una lista de todas las simulaciones disponibles
     * @summary Listar todas las simulaciones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getAllSimulations(options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getAllSimulations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene la lista de bloqueos activos en la simulación
     * @summary Listar bloqueos
     * @param {string} id ID de la simulación
     * @param {boolean} [activeOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getBlockages(id: string, activeOnly?: boolean, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getBlockages(id, activeOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene información detallada del entorno de simulación
     * @summary Obtener detalles del entorno
     * @param {string} id ID de la simulación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getEnvironment(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getEnvironment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene la lista de órdenes en la simulación
     * @summary Listar órdenes
     * @param {string} id ID de la simulación
     * @param {boolean} [pendingOnly] 
     * @param {boolean} [overdueOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getOrders(id: string, pendingOnly?: boolean, overdueOnly?: boolean, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getOrders(id, pendingOnly, overdueOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene el reporte de una simulación finalizada
     * @summary Obtener reporte de simulación
     * @param {string} id ID de la simulación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getSimulationReport(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getSimulationReport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene el estado actual de una simulación específica
     * @summary Obtener estado de una simulación
     * @param {string} id ID de la simulación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getSimulationStatus(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getSimulationStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Obtiene la lista de vehículos en la simulación
     * @summary Listar vehículos
     * @param {string} id ID de la simulación
     * @param {GetVehiclesStatusEnum} [status] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public getVehicles(id: string, status?: GetVehiclesStatusEnum, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).getVehicles(id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pausa la ejecución de una simulación
     * @summary Pausar simulación
     * @param {string} id ID de la simulación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public pauseSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).pauseSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simula la reparación de un vehículo averiado
     * @summary Reparar vehículo
     * @param {string} id ID de la simulación
     * @param {string} vehicleId ID del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public repairVehicle(id: string, vehicleId: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).repairVehicle(id, vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ajusta la velocidad de ejecución de la simulación
     * @summary Ajustar velocidad de simulación
     * @param {string} id ID de la simulación
     * @param {number} speedFactor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public setSimulationSpeed(id: string, speedFactor: number, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).setSimulationSpeed(id, speedFactor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Simula una avería en un vehículo específico
     * @summary Simular avería de vehículo
     * @param {string} id ID de la simulación
     * @param {string} vehicleId ID del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public simulateVehicleBreakdown(id: string, vehicleId: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).simulateVehicleBreakdown(id, vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Inicia o reanuda la ejecución de una simulación
     * @summary Iniciar simulación
     * @param {string} id ID de la simulación
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimulationApi
     */
    public startSimulation(id: string, options?: RawAxiosRequestConfig) {
        return SimulationApiFp(this.configuration).startSimulation(id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetVehiclesStatusEnum = {
    Available: 'AVAILABLE',
    Driving: 'DRIVING',
    Maintenance: 'MAINTENANCE',
    Refueling: 'REFUELING',
    Reloading: 'RELOADING',
    Serving: 'SERVING',
    Incident: 'INCIDENT',
    Idle: 'IDLE'
} as const;
export type GetVehiclesStatusEnum = typeof GetVehiclesStatusEnum[keyof typeof GetVehiclesStatusEnum];


/**
 * VehicleControllerApi - axios parameter creator
 * @export
 */
export const VehicleControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (vehicleDTO: VehicleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleDTO' is not null or undefined
            assertParamExists('create', 'vehicleDTO', vehicleDTO)
            const localVarPath = `/api/vehicles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vehicleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById', 'id', id)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ListTypeEnum} [type] 
         * @param {ListStatusEnum} [status] 
         * @param {number} [minGlp] 
         * @param {number} [minFuel] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (minGlp !== undefined) {
                localVarQueryParameter['minGlp'] = minGlp;
            }

            if (minFuel !== undefined) {
                localVarQueryParameter['minFuel'] = minFuel;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} distanceKm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveVehicle: async (id: string, distanceKm: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveVehicle', 'id', id)
            // verify required parameter 'distanceKm' is not null or undefined
            assertParamExists('moveVehicle', 'distanceKm', distanceKm)
            const localVarPath = `/api/vehicles/{id}/move`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (distanceKm !== undefined) {
                localVarQueryParameter['distanceKm'] = distanceKm;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {number} volumeM3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refillGlp: async (id: string, volumeM3: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refillGlp', 'id', id)
            // verify required parameter 'volumeM3' is not null or undefined
            assertParamExists('refillGlp', 'volumeM3', volumeM3)
            const localVarPath = `/api/vehicles/{id}/refill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (volumeM3 !== undefined) {
                localVarQueryParameter['volumeM3'] = volumeM3;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuel: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refuel', 'id', id)
            const localVarPath = `/api/vehicles/{id}/refuel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} orderId 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveOrder: async (id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serveOrder', 'id', id)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('serveOrder', 'orderId', orderId)
            // verify required parameter 'deliveryRecordDTO' is not null or undefined
            assertParamExists('serveOrder', 'deliveryRecordDTO', deliveryRecordDTO)
            const localVarPath = `/api/vehicles/{id}/serve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deliveryRecordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, vehicleDTO: VehicleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'vehicleDTO' is not null or undefined
            assertParamExists('update', 'vehicleDTO', vehicleDTO)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vehicleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehicleControllerApi - functional programming interface
 * @export
 */
export const VehicleControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VehicleControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(vehicleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ListTypeEnum} [type] 
         * @param {ListStatusEnum} [status] 
         * @param {number} [minGlp] 
         * @param {number} [minFuel] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(type, status, minGlp, minFuel, paginated, page, size, sortBy, direction, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} distanceKm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveVehicle(id: string, distanceKm: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveVehicle(id, distanceKm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.moveVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {number} volumeM3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refillGlp(id: string, volumeM3: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refillGlp(id, volumeM3, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.refillGlp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refuel(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refuel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.refuel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} orderId 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveOrder(id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServeRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveOrder(id, orderId, deliveryRecordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.serveOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, vehicleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehicleControllerApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VehicleControllerApi - factory interface
 * @export
 */
export const VehicleControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VehicleControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.create(vehicleDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.getById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ListTypeEnum} [type] 
         * @param {ListStatusEnum} [status] 
         * @param {number} [minGlp] 
         * @param {number} [minFuel] 
         * @param {boolean} [paginated] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {string} [sortBy] 
         * @param {string} [direction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.list(type, status, minGlp, minFuel, paginated, page, size, sortBy, direction, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} distanceKm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveVehicle(id: string, distanceKm: number, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.moveVehicle(id, distanceKm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {number} volumeM3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refillGlp(id: string, volumeM3: number, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.refillGlp(id, volumeM3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refuel(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.refuel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} orderId 
         * @param {DeliveryRecordDTO} deliveryRecordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveOrder(id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig): AxiosPromise<ServeRecordDTO> {
            return localVarFp.serveOrder(id, orderId, deliveryRecordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {VehicleDTO} vehicleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(id: string, vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig): AxiosPromise<VehicleDTO> {
            return localVarFp.update(id, vehicleDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VehicleControllerApi - object-oriented interface
 * @export
 * @class VehicleControllerApi
 * @extends {BaseAPI}
 */
export class VehicleControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public _delete(id: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VehicleDTO} vehicleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public create(vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).create(vehicleDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public getById(id: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).getById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ListTypeEnum} [type] 
     * @param {ListStatusEnum} [status] 
     * @param {number} [minGlp] 
     * @param {number} [minFuel] 
     * @param {boolean} [paginated] 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {string} [sortBy] 
     * @param {string} [direction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public list(type?: ListTypeEnum, status?: ListStatusEnum, minGlp?: number, minFuel?: number, paginated?: boolean, page?: number, size?: number, sortBy?: string, direction?: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).list(type, status, minGlp, minFuel, paginated, page, size, sortBy, direction, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} distanceKm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public moveVehicle(id: string, distanceKm: number, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).moveVehicle(id, distanceKm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {number} volumeM3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public refillGlp(id: string, volumeM3: number, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).refillGlp(id, volumeM3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public refuel(id: string, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).refuel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} orderId 
     * @param {DeliveryRecordDTO} deliveryRecordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public serveOrder(id: string, orderId: string, deliveryRecordDTO: DeliveryRecordDTO, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).serveOrder(id, orderId, deliveryRecordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {VehicleDTO} vehicleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleControllerApi
     */
    public update(id: string, vehicleDTO: VehicleDTO, options?: RawAxiosRequestConfig) {
        return VehicleControllerApiFp(this.configuration).update(id, vehicleDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;
export type ListTypeEnum = typeof ListTypeEnum[keyof typeof ListTypeEnum];
/**
 * @export
 */
export const ListStatusEnum = {
    Available: 'AVAILABLE',
    Driving: 'DRIVING',
    Maintenance: 'MAINTENANCE',
    Refueling: 'REFUELING',
    Reloading: 'RELOADING',
    Serving: 'SERVING',
    Incident: 'INCIDENT',
    Idle: 'IDLE'
} as const;
export type ListStatusEnum = typeof ListStatusEnum[keyof typeof ListStatusEnum];


