/* tslint:disable */
/* eslint-disable */
/**
 * PLG System Management API
 * API para la gestión del sistema PLG (Propane Liquid Gas). Incluye gestión de vehículos, mantenimientos, bloqueos, incidentes y órdenes.
 *
 * The version of the OpenAPI document: 1.0
 * Contact: plgsystem@example.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Blockage
 */
export interface Blockage {
    /**
     * 
     * @type {number}
     * @memberof Blockage
     */
    'id'?: number;
    /**
     * 
     * @type {Position}
     * @memberof Blockage
     */
    'startNode'?: Position;
    /**
     * 
     * @type {Position}
     * @memberof Blockage
     */
    'endNode'?: Position;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Blockage
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @interface Depot
 */
export interface Depot {
    /**
     * 
     * @type {Position}
     * @memberof Depot
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof Depot
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'glpCapacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'fuelCapacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'currentGLP'?: number;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'currentFuel'?: number;
    /**
     * 
     * @type {number}
     * @memberof Depot
     */
    'glpMinThreshold'?: number;
}
/**
 * 
 * @export
 * @interface Incident
 */
export interface Incident {
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'type'?: IncidentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'occurrenceTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'resolutionTime'?: string;
    /**
     * 
     * @type {Position}
     * @memberof Incident
     */
    'location'?: Position;
    /**
     * 
     * @type {IncidentOnSiteImmobilizationDuration}
     * @memberof Incident
     */
    'onSiteImmobilizationDuration'?: IncidentOnSiteImmobilizationDuration;
    /**
     * 
     * @type {IncidentOnSiteImmobilizationDuration}
     * @memberof Incident
     */
    'workshopRepairDuration'?: IncidentOnSiteImmobilizationDuration;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Incident
     */
    'resolved'?: boolean;
    /**
     * 
     * @type {Position}
     * @memberof Incident
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof Incident
     */
    'timestamp'?: string;
}

export const IncidentTypeEnum = {
    Type1: 'TYPE_1',
    Type2: 'TYPE_2',
    Type3: 'TYPE_3'
} as const;

export type IncidentTypeEnum = typeof IncidentTypeEnum[keyof typeof IncidentTypeEnum];

/**
 * 
 * @export
 * @interface IncidentOnSiteImmobilizationDuration
 */
export interface IncidentOnSiteImmobilizationDuration {
    /**
     * 
     * @type {number}
     * @memberof IncidentOnSiteImmobilizationDuration
     */
    'seconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDuration
     */
    'zero'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IncidentOnSiteImmobilizationDuration
     */
    'nano'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDuration
     */
    'negative'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDuration
     */
    'positive'?: boolean;
    /**
     * 
     * @type {Array<IncidentOnSiteImmobilizationDurationUnitsInner>}
     * @memberof IncidentOnSiteImmobilizationDuration
     */
    'units'?: Array<IncidentOnSiteImmobilizationDurationUnitsInner>;
}
/**
 * 
 * @export
 * @interface IncidentOnSiteImmobilizationDurationUnitsInner
 */
export interface IncidentOnSiteImmobilizationDurationUnitsInner {
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInner
     */
    'durationEstimated'?: boolean;
    /**
     * 
     * @type {IncidentOnSiteImmobilizationDurationUnitsInnerDuration}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInner
     */
    'duration'?: IncidentOnSiteImmobilizationDurationUnitsInnerDuration;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInner
     */
    'timeBased'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInner
     */
    'dateBased'?: boolean;
}
/**
 * 
 * @export
 * @interface IncidentOnSiteImmobilizationDurationUnitsInnerDuration
 */
export interface IncidentOnSiteImmobilizationDurationUnitsInnerDuration {
    /**
     * 
     * @type {number}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInnerDuration
     */
    'seconds'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInnerDuration
     */
    'zero'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInnerDuration
     */
    'nano'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInnerDuration
     */
    'negative'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IncidentOnSiteImmobilizationDurationUnitsInnerDuration
     */
    'positive'?: boolean;
}
/**
 * 
 * @export
 * @interface Maintenance
 */
export interface Maintenance {
    /**
     * 
     * @type {number}
     * @memberof Maintenance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'vehicleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'endDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'type'?: MaintenanceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Maintenance
     */
    'completed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Maintenance
     */
    'scheduledDate'?: string;
}

export const MaintenanceTypeEnum = {
    Preventive: 'PREVENTIVE',
    Corrective: 'CORRECTIVE'
} as const;

export type MaintenanceTypeEnum = typeof MaintenanceTypeEnum[keyof typeof MaintenanceTypeEnum];

/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {Position}
     * @memberof Order
     */
    'position'?: Position;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'arriveDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'dueDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'remainingVolume'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'glpRequest'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'deliveryDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'remainingGLP'?: number;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'x'?: number;
    /**
     * 
     * @type {number}
     * @memberof Position
     */
    'y'?: number;
}
/**
 * 
 * @export
 * @interface Vehicle
 */
export interface Vehicle {
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'type'?: VehicleTypeEnum;
    /**
     * 
     * @type {Position}
     * @memberof Vehicle
     */
    'currentPosition'?: Position;
    /**
     * 
     * @type {string}
     * @memberof Vehicle
     */
    'status'?: VehicleStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentCombinedWeightTon'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentGlpWeightTon'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'glpCapacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'fuelCapacity'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentGLP'?: number;
    /**
     * 
     * @type {number}
     * @memberof Vehicle
     */
    'currentFuel'?: number;
}

export const VehicleTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;

export type VehicleTypeEnum = typeof VehicleTypeEnum[keyof typeof VehicleTypeEnum];
export const VehicleStatusEnum = {
    Available: 'AVAILABLE',
    InTransit: 'IN_TRANSIT',
    Maintenance: 'MAINTENANCE',
    BrokenDown: 'BROKEN_DOWN'
} as const;

export type VehicleStatusEnum = typeof VehicleStatusEnum[keyof typeof VehicleStatusEnum];


/**
 * BlockagesApi - axios parameter creator
 * @export
 */
export const BlockagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registra un nuevo bloqueo en el sistema
         * @summary Crear nuevo bloqueo
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockage: async (blockage: Blockage, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockage' is not null or undefined
            assertParamExists('createBlockage', 'blockage', blockage)
            const localVarPath = `/api/blockages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un bloqueo del sistema
         * @summary Eliminar bloqueo
         * @param {number} id ID del bloqueo a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlockage: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBlockage', 'id', id)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los bloqueos actualmente activos
         * @summary Obtener bloqueos activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBlockages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/blockages/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna bloqueos activos en una fecha y hora específica
         * @summary Obtener bloqueos activos en fecha específica
         * @param {string} dateTime Fecha y hora para consultar (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBlockagesAt: async (dateTime: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dateTime' is not null or undefined
            assertParamExists('getActiveBlockagesAt', 'dateTime', dateTime)
            const localVarPath = `/api/blockages/active/{dateTime}`
                .replace(`{${"dateTime"}}`, encodeURIComponent(String(dateTime)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna la lista completa de bloqueos registrados
         * @summary Obtener todos los bloqueos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBlockages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/blockages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna un bloqueo específico
         * @summary Obtener bloqueo por ID
         * @param {number} id ID del bloqueo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockageById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBlockageById', 'id', id)
            const localVarPath = `/api/blockages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna bloqueos en un rango de fechas específico
         * @summary Obtener bloqueos por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockagesByDateRange: async (startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getBlockagesByDateRange', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getBlockagesByDateRange', 'endDate', endDate)
            const localVarPath = `/api/blockages/date-range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna bloqueos que afectan un segmento específico de ruta
         * @summary Obtener bloqueos en segmento
         * @param {number} x1 Coordenada X del punto inicial
         * @param {number} y1 Coordenada Y del punto inicial
         * @param {number} x2 Coordenada X del punto final
         * @param {number} y2 Coordenada Y del punto final
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockagesForSegment: async (x1: number, y1: number, x2: number, y2: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x1' is not null or undefined
            assertParamExists('getBlockagesForSegment', 'x1', x1)
            // verify required parameter 'y1' is not null or undefined
            assertParamExists('getBlockagesForSegment', 'y1', y1)
            // verify required parameter 'x2' is not null or undefined
            assertParamExists('getBlockagesForSegment', 'x2', x2)
            // verify required parameter 'y2' is not null or undefined
            assertParamExists('getBlockagesForSegment', 'y2', y2)
            const localVarPath = `/api/blockages/segment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (x1 !== undefined) {
                localVarQueryParameter['x1'] = x1;
            }

            if (y1 !== undefined) {
                localVarQueryParameter['y1'] = y1;
            }

            if (x2 !== undefined) {
                localVarQueryParameter['x2'] = x2;
            }

            if (y2 !== undefined) {
                localVarQueryParameter['y2'] = y2;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockagesApi - functional programming interface
 * @export
 */
export const BlockagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Registra un nuevo bloqueo en el sistema
         * @summary Crear nuevo bloqueo
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBlockage(blockage: Blockage, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBlockage(blockage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.createBlockage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina un bloqueo del sistema
         * @summary Eliminar bloqueo
         * @param {number} id ID del bloqueo a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBlockage(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBlockage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.deleteBlockage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los bloqueos actualmente activos
         * @summary Obtener bloqueos activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveBlockages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Blockage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveBlockages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.getActiveBlockages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna bloqueos activos en una fecha y hora específica
         * @summary Obtener bloqueos activos en fecha específica
         * @param {string} dateTime Fecha y hora para consultar (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveBlockagesAt(dateTime: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Blockage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveBlockagesAt(dateTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.getActiveBlockagesAt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la lista completa de bloqueos registrados
         * @summary Obtener todos los bloqueos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBlockages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBlockages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.getAllBlockages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna un bloqueo específico
         * @summary Obtener bloqueo por ID
         * @param {number} id ID del bloqueo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockageById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Blockage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockageById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.getBlockageById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna bloqueos en un rango de fechas específico
         * @summary Obtener bloqueos por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockagesByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Blockage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockagesByDateRange(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.getBlockagesByDateRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna bloqueos que afectan un segmento específico de ruta
         * @summary Obtener bloqueos en segmento
         * @param {number} x1 Coordenada X del punto inicial
         * @param {number} y1 Coordenada Y del punto inicial
         * @param {number} x2 Coordenada X del punto final
         * @param {number} y2 Coordenada Y del punto final
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockagesForSegment(x1: number, y1: number, x2: number, y2: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Blockage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockagesForSegment(x1, y1, x2, y2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BlockagesApi.getBlockagesForSegment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BlockagesApi - factory interface
 * @export
 */
export const BlockagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockagesApiFp(configuration)
    return {
        /**
         * Registra un nuevo bloqueo en el sistema
         * @summary Crear nuevo bloqueo
         * @param {Blockage} blockage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBlockage(blockage: Blockage, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.createBlockage(blockage, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un bloqueo del sistema
         * @summary Eliminar bloqueo
         * @param {number} id ID del bloqueo a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBlockage(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteBlockage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los bloqueos actualmente activos
         * @summary Obtener bloqueos activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBlockages(options?: RawAxiosRequestConfig): AxiosPromise<Array<Blockage>> {
            return localVarFp.getActiveBlockages(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna bloqueos activos en una fecha y hora específica
         * @summary Obtener bloqueos activos en fecha específica
         * @param {string} dateTime Fecha y hora para consultar (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveBlockagesAt(dateTime: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Blockage>> {
            return localVarFp.getActiveBlockagesAt(dateTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la lista completa de bloqueos registrados
         * @summary Obtener todos los bloqueos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBlockages(options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.getAllBlockages(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna un bloqueo específico
         * @summary Obtener bloqueo por ID
         * @param {number} id ID del bloqueo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockageById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Blockage> {
            return localVarFp.getBlockageById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna bloqueos en un rango de fechas específico
         * @summary Obtener bloqueos por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockagesByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Blockage>> {
            return localVarFp.getBlockagesByDateRange(startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna bloqueos que afectan un segmento específico de ruta
         * @summary Obtener bloqueos en segmento
         * @param {number} x1 Coordenada X del punto inicial
         * @param {number} y1 Coordenada Y del punto inicial
         * @param {number} x2 Coordenada X del punto final
         * @param {number} y2 Coordenada Y del punto final
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockagesForSegment(x1: number, y1: number, x2: number, y2: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Blockage>> {
            return localVarFp.getBlockagesForSegment(x1, y1, x2, y2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockagesApi - object-oriented interface
 * @export
 * @class BlockagesApi
 * @extends {BaseAPI}
 */
export class BlockagesApi extends BaseAPI {
    /**
     * Registra un nuevo bloqueo en el sistema
     * @summary Crear nuevo bloqueo
     * @param {Blockage} blockage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public createBlockage(blockage: Blockage, options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).createBlockage(blockage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un bloqueo del sistema
     * @summary Eliminar bloqueo
     * @param {number} id ID del bloqueo a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public deleteBlockage(id: number, options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).deleteBlockage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los bloqueos actualmente activos
     * @summary Obtener bloqueos activos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public getActiveBlockages(options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).getActiveBlockages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna bloqueos activos en una fecha y hora específica
     * @summary Obtener bloqueos activos en fecha específica
     * @param {string} dateTime Fecha y hora para consultar (ISO 8601)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public getActiveBlockagesAt(dateTime: string, options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).getActiveBlockagesAt(dateTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la lista completa de bloqueos registrados
     * @summary Obtener todos los bloqueos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public getAllBlockages(options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).getAllBlockages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna un bloqueo específico
     * @summary Obtener bloqueo por ID
     * @param {number} id ID del bloqueo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public getBlockageById(id: number, options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).getBlockageById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna bloqueos en un rango de fechas específico
     * @summary Obtener bloqueos por rango de fechas
     * @param {string} startDate Fecha de inicio (ISO 8601)
     * @param {string} endDate Fecha de fin (ISO 8601)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public getBlockagesByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).getBlockagesByDateRange(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna bloqueos que afectan un segmento específico de ruta
     * @summary Obtener bloqueos en segmento
     * @param {number} x1 Coordenada X del punto inicial
     * @param {number} y1 Coordenada Y del punto inicial
     * @param {number} x2 Coordenada X del punto final
     * @param {number} y2 Coordenada Y del punto final
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockagesApi
     */
    public getBlockagesForSegment(x1: number, y1: number, x2: number, y2: number, options?: RawAxiosRequestConfig) {
        return BlockagesApiFp(this.configuration).getBlockagesForSegment(x1, y1, x2, y2, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardOverview: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/system-health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrgentOrders1: async (hoursAhead?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/urgent-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (hoursAhead !== undefined) {
                localVarQueryParameter['hoursAhead'] = hoursAhead;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleStatusBreakdown: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/dashboard/vehicle-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardOverview(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardOverview(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getDashboardOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getSystemHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrgentOrders1(hoursAhead?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrgentOrders1(hoursAhead, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getUrgentOrders1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehicleStatusBreakdown(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehicleStatusBreakdown(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.getVehicleStatusBreakdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
         * @summary Obtener resumen del dashboard
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardOverview(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDashboardOverview(options).then((request) => request(axios, basePath));
        },
        /**
         * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
         * @summary Obtener salud del sistema
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemHealth(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getSystemHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve las órdenes que vencen dentro del plazo especificado
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrgentOrders1(hoursAhead?: number, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.getUrgentOrders1(hoursAhead, options).then((request) => request(axios, basePath));
        },
        /**
         * Devuelve un desglose de vehículos agrupados por su estado operativo
         * @summary Obtener estado de vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleStatusBreakdown(options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.getVehicleStatusBreakdown(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * Proporciona estadísticas generales del sistema incluyendo vehículos, órdenes, depósitos y estado operacional
     * @summary Obtener resumen del dashboard
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getDashboardOverview(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getDashboardOverview(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calcula y devuelve puntuaciones de salud del sistema basadas en vehículos, incidentes y órdenes
     * @summary Obtener salud del sistema
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getSystemHealth(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getSystemHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve las órdenes que vencen dentro del plazo especificado
     * @summary Obtener órdenes urgentes
     * @param {number} [hoursAhead] Horas de anticipación para considerar urgente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getUrgentOrders1(hoursAhead?: number, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getUrgentOrders1(hoursAhead, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Devuelve un desglose de vehículos agrupados por su estado operativo
     * @summary Obtener estado de vehículos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getVehicleStatusBreakdown(options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).getVehicleStatusBreakdown(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DepotsApi - axios parameter creator
 * @export
 */
export const DepotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registra un nuevo depósito en el sistema
         * @summary Crear nuevo depósito
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepot: async (depot: Depot, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'depot' is not null or undefined
            assertParamExists('createDepot', 'depot', depot)
            const localVarPath = `/api/depots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(depot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un depósito del sistema
         * @summary Eliminar depósito
         * @param {string} id ID del depósito a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDepot: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDepot', 'id', id)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna la lista completa de depósitos registrados
         * @summary Obtener todos los depósitos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDepots: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/depots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna la cantidad total de GLP actualmente almacenada en todos los depósitos
         * @summary Obtener GLP total actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTotalGLP: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/depots/glp/current-total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna un depósito específico
         * @summary Obtener depósito por ID
         * @param {string} id ID del depósito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDepotById', 'id', id)
            const localVarPath = `/api/depots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna depósitos dentro de un rango geográfico específico
         * @summary Obtener depósitos por rango de ubicación
         * @param {number} minX Coordenada X mínima
         * @param {number} maxX Coordenada X máxima
         * @param {number} minY Coordenada Y mínima
         * @param {number} maxY Coordenada Y máxima
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsByLocationRange: async (minX: number, maxX: number, minY: number, maxY: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'minX' is not null or undefined
            assertParamExists('getDepotsByLocationRange', 'minX', minX)
            // verify required parameter 'maxX' is not null or undefined
            assertParamExists('getDepotsByLocationRange', 'maxX', maxX)
            // verify required parameter 'minY' is not null or undefined
            assertParamExists('getDepotsByLocationRange', 'minY', minY)
            // verify required parameter 'maxY' is not null or undefined
            assertParamExists('getDepotsByLocationRange', 'maxY', maxY)
            const localVarPath = `/api/depots/location-range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minX !== undefined) {
                localVarQueryParameter['minX'] = minX;
            }

            if (maxX !== undefined) {
                localVarQueryParameter['maxX'] = maxX;
            }

            if (minY !== undefined) {
                localVarQueryParameter['minY'] = minY;
            }

            if (maxY !== undefined) {
                localVarQueryParameter['maxY'] = maxY;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna depósitos dentro de un radio específico desde una posición
         * @summary Obtener depósitos por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsByRadius: async (x: number, y: number, radius: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x' is not null or undefined
            assertParamExists('getDepotsByRadius', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('getDepotsByRadius', 'y', y)
            // verify required parameter 'radius' is not null or undefined
            assertParamExists('getDepotsByRadius', 'radius', radius)
            const localVarPath = `/api/depots/radius`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (x !== undefined) {
                localVarQueryParameter['x'] = x;
            }

            if (y !== undefined) {
                localVarQueryParameter['y'] = y;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna depósitos que tienen al menos la capacidad libre mínima especificada
         * @summary Obtener depósitos con capacidad disponible
         * @param {number} minCapacity Capacidad mínima libre requerida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsWithAvailableCapacity: async (minCapacity: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'minCapacity' is not null or undefined
            assertParamExists('getDepotsWithAvailableCapacity', 'minCapacity', minCapacity)
            const localVarPath = `/api/depots/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minCapacity !== undefined) {
                localVarQueryParameter['minCapacity'] = minCapacity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna depósitos que tienen al menos la cantidad requerida de GLP
         * @summary Obtener depósitos con GLP suficiente
         * @param {number} requiredGLP Cantidad mínima de GLP requerida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsWithSufficientGLP: async (requiredGLP: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requiredGLP' is not null or undefined
            assertParamExists('getDepotsWithSufficientGLP', 'requiredGLP', requiredGLP)
            const localVarPath = `/api/depots/sufficient-glp/{requiredGLP}`
                .replace(`{${"requiredGLP"}}`, encodeURIComponent(String(requiredGLP)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna la capacidad total de almacenamiento de todos los depósitos
         * @summary Obtener capacidad total de almacenamiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalStorageCapacity: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/depots/capacity/total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rellena un depósito a su capacidad máxima
         * @summary Rellenar depósito
         * @param {string} id ID del depósito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refillDepot: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('refillDepot', 'id', id)
            const localVarPath = `/api/depots/{id}/refill`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retira una cantidad específica de GLP del depósito
         * @summary Servir GLP desde depósito
         * @param {string} id ID del depósito
         * @param {number} requestedGLP Cantidad de GLP solicitada
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFromDepot: async (id: string, requestedGLP: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serveFromDepot', 'id', id)
            // verify required parameter 'requestedGLP' is not null or undefined
            assertParamExists('serveFromDepot', 'requestedGLP', requestedGLP)
            const localVarPath = `/api/depots/{id}/serve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requestedGLP !== undefined) {
                localVarQueryParameter['requestedGLP'] = requestedGLP;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ajusta el nivel de GLP de un depósito (puede ser positivo o negativo)
         * @summary Actualizar nivel de GLP
         * @param {string} id ID del depósito
         * @param {number} amount Cantidad a agregar/restar al nivel actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGLPLevel1: async (id: string, amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGLPLevel1', 'id', id)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('updateGLPLevel1', 'amount', amount)
            const localVarPath = `/api/depots/{id}/glp`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza el umbral mínimo de GLP para un depósito
         * @summary Actualizar umbral mínimo
         * @param {string} id ID del depósito
         * @param {number} threshold Nuevo umbral mínimo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMinimumThreshold: async (id: string, threshold: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMinimumThreshold', 'id', id)
            // verify required parameter 'threshold' is not null or undefined
            assertParamExists('updateMinimumThreshold', 'threshold', threshold)
            const localVarPath = `/api/depots/{id}/threshold`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (threshold !== undefined) {
                localVarQueryParameter['threshold'] = threshold;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DepotsApi - functional programming interface
 * @export
 */
export const DepotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DepotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Registra un nuevo depósito en el sistema
         * @summary Crear nuevo depósito
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDepot(depot: Depot, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDepot(depot, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.createDepot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina un depósito del sistema
         * @summary Eliminar depósito
         * @param {string} id ID del depósito a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDepot(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDepot(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.deleteDepot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la lista completa de depósitos registrados
         * @summary Obtener todos los depósitos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDepots(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDepots(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getAllDepots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la cantidad total de GLP actualmente almacenada en todos los depósitos
         * @summary Obtener GLP total actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentTotalGLP(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentTotalGLP(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getCurrentTotalGLP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna un depósito específico
         * @summary Obtener depósito por ID
         * @param {string} id ID del depósito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepotById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepotById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getDepotById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna depósitos dentro de un rango geográfico específico
         * @summary Obtener depósitos por rango de ubicación
         * @param {number} minX Coordenada X mínima
         * @param {number} maxX Coordenada X máxima
         * @param {number} minY Coordenada Y mínima
         * @param {number} maxY Coordenada Y máxima
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepotsByLocationRange(minX: number, maxX: number, minY: number, maxY: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Depot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepotsByLocationRange(minX, maxX, minY, maxY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getDepotsByLocationRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna depósitos dentro de un radio específico desde una posición
         * @summary Obtener depósitos por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepotsByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Depot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepotsByRadius(x, y, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getDepotsByRadius']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna depósitos que tienen al menos la capacidad libre mínima especificada
         * @summary Obtener depósitos con capacidad disponible
         * @param {number} minCapacity Capacidad mínima libre requerida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepotsWithAvailableCapacity(minCapacity: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Depot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepotsWithAvailableCapacity(minCapacity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getDepotsWithAvailableCapacity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna depósitos que tienen al menos la cantidad requerida de GLP
         * @summary Obtener depósitos con GLP suficiente
         * @param {number} requiredGLP Cantidad mínima de GLP requerida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDepotsWithSufficientGLP(requiredGLP: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Depot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDepotsWithSufficientGLP(requiredGLP, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getDepotsWithSufficientGLP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la capacidad total de almacenamiento de todos los depósitos
         * @summary Obtener capacidad total de almacenamiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalStorageCapacity(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalStorageCapacity(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.getTotalStorageCapacity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rellena un depósito a su capacidad máxima
         * @summary Rellenar depósito
         * @param {string} id ID del depósito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refillDepot(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refillDepot(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.refillDepot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retira una cantidad específica de GLP del depósito
         * @summary Servir GLP desde depósito
         * @param {string} id ID del depósito
         * @param {number} requestedGLP Cantidad de GLP solicitada
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveFromDepot(id: string, requestedGLP: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveFromDepot(id, requestedGLP, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.serveFromDepot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Ajusta el nivel de GLP de un depósito (puede ser positivo o negativo)
         * @summary Actualizar nivel de GLP
         * @param {string} id ID del depósito
         * @param {number} amount Cantidad a agregar/restar al nivel actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGLPLevel1(id: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGLPLevel1(id, amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.updateGLPLevel1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Actualiza el umbral mínimo de GLP para un depósito
         * @summary Actualizar umbral mínimo
         * @param {string} id ID del depósito
         * @param {number} threshold Nuevo umbral mínimo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMinimumThreshold(id: string, threshold: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Depot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMinimumThreshold(id, threshold, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DepotsApi.updateMinimumThreshold']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DepotsApi - factory interface
 * @export
 */
export const DepotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DepotsApiFp(configuration)
    return {
        /**
         * Registra un nuevo depósito en el sistema
         * @summary Crear nuevo depósito
         * @param {Depot} depot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDepot(depot: Depot, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.createDepot(depot, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un depósito del sistema
         * @summary Eliminar depósito
         * @param {string} id ID del depósito a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDepot(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDepot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la lista completa de depósitos registrados
         * @summary Obtener todos los depósitos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDepots(options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.getAllDepots(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la cantidad total de GLP actualmente almacenada en todos los depósitos
         * @summary Obtener GLP total actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentTotalGLP(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getCurrentTotalGLP(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna un depósito específico
         * @summary Obtener depósito por ID
         * @param {string} id ID del depósito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.getDepotById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna depósitos dentro de un rango geográfico específico
         * @summary Obtener depósitos por rango de ubicación
         * @param {number} minX Coordenada X mínima
         * @param {number} maxX Coordenada X máxima
         * @param {number} minY Coordenada Y mínima
         * @param {number} maxY Coordenada Y máxima
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsByLocationRange(minX: number, maxX: number, minY: number, maxY: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Depot>> {
            return localVarFp.getDepotsByLocationRange(minX, maxX, minY, maxY, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna depósitos dentro de un radio específico desde una posición
         * @summary Obtener depósitos por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Depot>> {
            return localVarFp.getDepotsByRadius(x, y, radius, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna depósitos que tienen al menos la capacidad libre mínima especificada
         * @summary Obtener depósitos con capacidad disponible
         * @param {number} minCapacity Capacidad mínima libre requerida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsWithAvailableCapacity(minCapacity: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Depot>> {
            return localVarFp.getDepotsWithAvailableCapacity(minCapacity, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna depósitos que tienen al menos la cantidad requerida de GLP
         * @summary Obtener depósitos con GLP suficiente
         * @param {number} requiredGLP Cantidad mínima de GLP requerida
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDepotsWithSufficientGLP(requiredGLP: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Depot>> {
            return localVarFp.getDepotsWithSufficientGLP(requiredGLP, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la capacidad total de almacenamiento de todos los depósitos
         * @summary Obtener capacidad total de almacenamiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalStorageCapacity(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getTotalStorageCapacity(options).then((request) => request(axios, basePath));
        },
        /**
         * Rellena un depósito a su capacidad máxima
         * @summary Rellenar depósito
         * @param {string} id ID del depósito
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refillDepot(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.refillDepot(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retira una cantidad específica de GLP del depósito
         * @summary Servir GLP desde depósito
         * @param {string} id ID del depósito
         * @param {number} requestedGLP Cantidad de GLP solicitada
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveFromDepot(id: string, requestedGLP: number, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.serveFromDepot(id, requestedGLP, options).then((request) => request(axios, basePath));
        },
        /**
         * Ajusta el nivel de GLP de un depósito (puede ser positivo o negativo)
         * @summary Actualizar nivel de GLP
         * @param {string} id ID del depósito
         * @param {number} amount Cantidad a agregar/restar al nivel actual
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGLPLevel1(id: string, amount: number, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.updateGLPLevel1(id, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Actualiza el umbral mínimo de GLP para un depósito
         * @summary Actualizar umbral mínimo
         * @param {string} id ID del depósito
         * @param {number} threshold Nuevo umbral mínimo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMinimumThreshold(id: string, threshold: number, options?: RawAxiosRequestConfig): AxiosPromise<Depot> {
            return localVarFp.updateMinimumThreshold(id, threshold, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DepotsApi - object-oriented interface
 * @export
 * @class DepotsApi
 * @extends {BaseAPI}
 */
export class DepotsApi extends BaseAPI {
    /**
     * Registra un nuevo depósito en el sistema
     * @summary Crear nuevo depósito
     * @param {Depot} depot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public createDepot(depot: Depot, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).createDepot(depot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un depósito del sistema
     * @summary Eliminar depósito
     * @param {string} id ID del depósito a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public deleteDepot(id: string, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).deleteDepot(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la lista completa de depósitos registrados
     * @summary Obtener todos los depósitos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getAllDepots(options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getAllDepots(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la cantidad total de GLP actualmente almacenada en todos los depósitos
     * @summary Obtener GLP total actual
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getCurrentTotalGLP(options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getCurrentTotalGLP(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna un depósito específico
     * @summary Obtener depósito por ID
     * @param {string} id ID del depósito
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getDepotById(id: string, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getDepotById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna depósitos dentro de un rango geográfico específico
     * @summary Obtener depósitos por rango de ubicación
     * @param {number} minX Coordenada X mínima
     * @param {number} maxX Coordenada X máxima
     * @param {number} minY Coordenada Y mínima
     * @param {number} maxY Coordenada Y máxima
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getDepotsByLocationRange(minX: number, maxX: number, minY: number, maxY: number, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getDepotsByLocationRange(minX, maxX, minY, maxY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna depósitos dentro de un radio específico desde una posición
     * @summary Obtener depósitos por radio
     * @param {number} x Coordenada X del centro
     * @param {number} y Coordenada Y del centro
     * @param {number} radius Radio de búsqueda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getDepotsByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getDepotsByRadius(x, y, radius, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna depósitos que tienen al menos la capacidad libre mínima especificada
     * @summary Obtener depósitos con capacidad disponible
     * @param {number} minCapacity Capacidad mínima libre requerida
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getDepotsWithAvailableCapacity(minCapacity: number, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getDepotsWithAvailableCapacity(minCapacity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna depósitos que tienen al menos la cantidad requerida de GLP
     * @summary Obtener depósitos con GLP suficiente
     * @param {number} requiredGLP Cantidad mínima de GLP requerida
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getDepotsWithSufficientGLP(requiredGLP: number, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getDepotsWithSufficientGLP(requiredGLP, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la capacidad total de almacenamiento de todos los depósitos
     * @summary Obtener capacidad total de almacenamiento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public getTotalStorageCapacity(options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).getTotalStorageCapacity(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rellena un depósito a su capacidad máxima
     * @summary Rellenar depósito
     * @param {string} id ID del depósito
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public refillDepot(id: string, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).refillDepot(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retira una cantidad específica de GLP del depósito
     * @summary Servir GLP desde depósito
     * @param {string} id ID del depósito
     * @param {number} requestedGLP Cantidad de GLP solicitada
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public serveFromDepot(id: string, requestedGLP: number, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).serveFromDepot(id, requestedGLP, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ajusta el nivel de GLP de un depósito (puede ser positivo o negativo)
     * @summary Actualizar nivel de GLP
     * @param {string} id ID del depósito
     * @param {number} amount Cantidad a agregar/restar al nivel actual
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public updateGLPLevel1(id: string, amount: number, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).updateGLPLevel1(id, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Actualiza el umbral mínimo de GLP para un depósito
     * @summary Actualizar umbral mínimo
     * @param {string} id ID del depósito
     * @param {number} threshold Nuevo umbral mínimo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepotsApi
     */
    public updateMinimumThreshold(id: string, threshold: number, options?: RawAxiosRequestConfig) {
        return DepotsApiFp(this.configuration).updateMinimumThreshold(id, threshold, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IncidentsApi - axios parameter creator
 * @export
 */
export const IncidentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Registra un nuevo incidente en el sistema
         * @summary Crear nuevo incidente
         * @param {Incident} incident 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident: async (incident: Incident, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'incident' is not null or undefined
            assertParamExists('createIncident', 'incident', incident)
            const localVarPath = `/api/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(incident, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un incidente del sistema
         * @summary Eliminar incidente
         * @param {string} id ID del incidente a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIncident: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIncident', 'id', id)
            const localVarPath = `/api/incidents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los incidentes actualmente activos (no resueltos)
         * @summary Obtener incidentes activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveIncidents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/incidents/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna incidentes activos de un vehículo específico
         * @summary Obtener incidentes activos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveIncidentsForVehicle: async (vehicleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('getActiveIncidentsForVehicle', 'vehicleId', vehicleId)
            const localVarPath = `/api/incidents/active/vehicle/{vehicleId}`
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna la lista completa de incidentes registrados
         * @summary Obtener todos los incidentes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIncidents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/incidents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna un incidente específico
         * @summary Obtener incidente por ID
         * @param {string} id ID del incidente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIncidentById', 'id', id)
            const localVarPath = `/api/incidents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna incidentes en un rango de fechas específico
         * @summary Obtener incidentes por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentsByDateRange: async (startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getIncidentsByDateRange', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getIncidentsByDateRange', 'endDate', endDate)
            const localVarPath = `/api/incidents/date-range`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna incidentes filtrados por tipo
         * @summary Obtener incidentes por tipo
         * @param {GetIncidentsByTypeTypeEnum} type Tipo de incidente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentsByType: async (type: GetIncidentsByTypeTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getIncidentsByType', 'type', type)
            const localVarPath = `/api/incidents/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los incidentes de un vehículo específico
         * @summary Obtener incidentes por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentsByVehicle: async (vehicleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('getIncidentsByVehicle', 'vehicleId', vehicleId)
            const localVarPath = `/api/incidents/vehicle/{vehicleId}`
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los incidentes que han sido resueltos
         * @summary Obtener incidentes resueltos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolvedIncidents: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/incidents/resolved`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncidentsApi - functional programming interface
 * @export
 */
export const IncidentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncidentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Registra un nuevo incidente en el sistema
         * @summary Crear nuevo incidente
         * @param {Incident} incident 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIncident(incident: Incident, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Incident>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIncident(incident, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.createIncident']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina un incidente del sistema
         * @summary Eliminar incidente
         * @param {string} id ID del incidente a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIncident(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIncident(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.deleteIncident']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los incidentes actualmente activos (no resueltos)
         * @summary Obtener incidentes activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveIncidents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Incident>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveIncidents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getActiveIncidents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna incidentes activos de un vehículo específico
         * @summary Obtener incidentes activos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveIncidentsForVehicle(vehicleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Incident>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveIncidentsForVehicle(vehicleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getActiveIncidentsForVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la lista completa de incidentes registrados
         * @summary Obtener todos los incidentes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllIncidents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Incident>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllIncidents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getAllIncidents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna un incidente específico
         * @summary Obtener incidente por ID
         * @param {string} id ID del incidente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncidentById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Incident>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncidentById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getIncidentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna incidentes en un rango de fechas específico
         * @summary Obtener incidentes por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncidentsByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Incident>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncidentsByDateRange(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getIncidentsByDateRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna incidentes filtrados por tipo
         * @summary Obtener incidentes por tipo
         * @param {GetIncidentsByTypeTypeEnum} type Tipo de incidente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncidentsByType(type: GetIncidentsByTypeTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Incident>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncidentsByType(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getIncidentsByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los incidentes de un vehículo específico
         * @summary Obtener incidentes por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIncidentsByVehicle(vehicleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Incident>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIncidentsByVehicle(vehicleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getIncidentsByVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los incidentes que han sido resueltos
         * @summary Obtener incidentes resueltos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResolvedIncidents(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Incident>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResolvedIncidents(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncidentsApi.getResolvedIncidents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IncidentsApi - factory interface
 * @export
 */
export const IncidentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncidentsApiFp(configuration)
    return {
        /**
         * Registra un nuevo incidente en el sistema
         * @summary Crear nuevo incidente
         * @param {Incident} incident 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIncident(incident: Incident, options?: RawAxiosRequestConfig): AxiosPromise<Incident> {
            return localVarFp.createIncident(incident, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un incidente del sistema
         * @summary Eliminar incidente
         * @param {string} id ID del incidente a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIncident(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteIncident(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los incidentes actualmente activos (no resueltos)
         * @summary Obtener incidentes activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveIncidents(options?: RawAxiosRequestConfig): AxiosPromise<Array<Incident>> {
            return localVarFp.getActiveIncidents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna incidentes activos de un vehículo específico
         * @summary Obtener incidentes activos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveIncidentsForVehicle(vehicleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Incident>> {
            return localVarFp.getActiveIncidentsForVehicle(vehicleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la lista completa de incidentes registrados
         * @summary Obtener todos los incidentes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllIncidents(options?: RawAxiosRequestConfig): AxiosPromise<Incident> {
            return localVarFp.getAllIncidents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna un incidente específico
         * @summary Obtener incidente por ID
         * @param {string} id ID del incidente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Incident> {
            return localVarFp.getIncidentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna incidentes en un rango de fechas específico
         * @summary Obtener incidentes por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentsByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Incident>> {
            return localVarFp.getIncidentsByDateRange(startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna incidentes filtrados por tipo
         * @summary Obtener incidentes por tipo
         * @param {GetIncidentsByTypeTypeEnum} type Tipo de incidente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentsByType(type: GetIncidentsByTypeTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Incident>> {
            return localVarFp.getIncidentsByType(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los incidentes de un vehículo específico
         * @summary Obtener incidentes por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIncidentsByVehicle(vehicleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Incident>> {
            return localVarFp.getIncidentsByVehicle(vehicleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los incidentes que han sido resueltos
         * @summary Obtener incidentes resueltos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResolvedIncidents(options?: RawAxiosRequestConfig): AxiosPromise<Array<Incident>> {
            return localVarFp.getResolvedIncidents(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncidentsApi - object-oriented interface
 * @export
 * @class IncidentsApi
 * @extends {BaseAPI}
 */
export class IncidentsApi extends BaseAPI {
    /**
     * Registra un nuevo incidente en el sistema
     * @summary Crear nuevo incidente
     * @param {Incident} incident 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public createIncident(incident: Incident, options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).createIncident(incident, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un incidente del sistema
     * @summary Eliminar incidente
     * @param {string} id ID del incidente a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public deleteIncident(id: string, options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).deleteIncident(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los incidentes actualmente activos (no resueltos)
     * @summary Obtener incidentes activos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getActiveIncidents(options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getActiveIncidents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna incidentes activos de un vehículo específico
     * @summary Obtener incidentes activos por vehículo
     * @param {string} vehicleId ID del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getActiveIncidentsForVehicle(vehicleId: string, options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getActiveIncidentsForVehicle(vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la lista completa de incidentes registrados
     * @summary Obtener todos los incidentes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getAllIncidents(options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getAllIncidents(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna un incidente específico
     * @summary Obtener incidente por ID
     * @param {string} id ID del incidente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getIncidentById(id: string, options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getIncidentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna incidentes en un rango de fechas específico
     * @summary Obtener incidentes por rango de fechas
     * @param {string} startDate Fecha de inicio (ISO 8601)
     * @param {string} endDate Fecha de fin (ISO 8601)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getIncidentsByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getIncidentsByDateRange(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna incidentes filtrados por tipo
     * @summary Obtener incidentes por tipo
     * @param {GetIncidentsByTypeTypeEnum} type Tipo de incidente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getIncidentsByType(type: GetIncidentsByTypeTypeEnum, options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getIncidentsByType(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los incidentes de un vehículo específico
     * @summary Obtener incidentes por vehículo
     * @param {string} vehicleId ID del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getIncidentsByVehicle(vehicleId: string, options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getIncidentsByVehicle(vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los incidentes que han sido resueltos
     * @summary Obtener incidentes resueltos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncidentsApi
     */
    public getResolvedIncidents(options?: RawAxiosRequestConfig) {
        return IncidentsApiFp(this.configuration).getResolvedIncidents(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetIncidentsByTypeTypeEnum = {
    Type1: 'TYPE_1',
    Type2: 'TYPE_2',
    Type3: 'TYPE_3'
} as const;
export type GetIncidentsByTypeTypeEnum = typeof GetIncidentsByTypeTypeEnum[keyof typeof GetIncidentsByTypeTypeEnum];


/**
 * MaintenanceApi - axios parameter creator
 * @export
 */
export const MaintenanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Marca un mantenimiento como completado
         * @summary Completar mantenimiento
         * @param {number} id ID del mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeMaintenance: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('completeMaintenance', 'id', id)
            const localVarPath = `/api/maintenance/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registra un nuevo mantenimiento en el sistema
         * @summary Crear nuevo mantenimiento
         * @param {Maintenance} maintenance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaintenance: async (maintenance: Maintenance, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'maintenance' is not null or undefined
            assertParamExists('createMaintenance', 'maintenance', maintenance)
            const localVarPath = `/api/maintenance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(maintenance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los mantenimientos actualmente en curso
         * @summary Obtener mantenimientos activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveMaintenance: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/maintenance/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna mantenimientos activos de un vehículo específico
         * @summary Obtener mantenimientos activos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveMaintenanceForVehicle: async (vehicleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('getActiveMaintenanceForVehicle', 'vehicleId', vehicleId)
            const localVarPath = `/api/maintenance/active/vehicle/{vehicleId}`
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna la lista completa de mantenimientos registrados
         * @summary Obtener todos los mantenimientos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaintenance: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/maintenance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna un mantenimiento específico
         * @summary Obtener mantenimiento por ID
         * @param {number} id ID del mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMaintenanceById', 'id', id)
            const localVarPath = `/api/maintenance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna mantenimientos filtrados por tipo
         * @summary Obtener mantenimientos por tipo
         * @param {GetMaintenanceByTypeTypeEnum} type Tipo de mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceByType: async (type: GetMaintenanceByTypeTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getMaintenanceByType', 'type', type)
            const localVarPath = `/api/maintenance/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los mantenimientos de un vehículo específico
         * @summary Obtener mantenimientos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceByVehicle: async (vehicleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('getMaintenanceByVehicle', 'vehicleId', vehicleId)
            const localVarPath = `/api/maintenance/vehicle/{vehicleId}`
                .replace(`{${"vehicleId"}}`, encodeURIComponent(String(vehicleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna mantenimientos programados en un rango de fechas
         * @summary Obtener mantenimientos próximos
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingMaintenance: async (startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('getUpcomingMaintenance', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('getUpcomingMaintenance', 'endDate', endDate)
            const localVarPath = `/api/maintenance/upcoming`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Programa un nuevo mantenimiento para un vehículo
         * @summary Programar mantenimiento
         * @param {string} vehicleId ID del vehículo
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {ScheduleMaintenanceTypeEnum} type Tipo de mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleMaintenance: async (vehicleId: string, startDate: string, type: ScheduleMaintenanceTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleId' is not null or undefined
            assertParamExists('scheduleMaintenance', 'vehicleId', vehicleId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('scheduleMaintenance', 'startDate', startDate)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('scheduleMaintenance', 'type', type)
            const localVarPath = `/api/maintenance/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleId !== undefined) {
                localVarQueryParameter['vehicleId'] = vehicleId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MaintenanceApi - functional programming interface
 * @export
 */
export const MaintenanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MaintenanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Marca un mantenimiento como completado
         * @summary Completar mantenimiento
         * @param {number} id ID del mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeMaintenance(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Maintenance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeMaintenance(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.completeMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registra un nuevo mantenimiento en el sistema
         * @summary Crear nuevo mantenimiento
         * @param {Maintenance} maintenance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMaintenance(maintenance: Maintenance, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Maintenance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMaintenance(maintenance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.createMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los mantenimientos actualmente en curso
         * @summary Obtener mantenimientos activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveMaintenance(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Maintenance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveMaintenance(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.getActiveMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna mantenimientos activos de un vehículo específico
         * @summary Obtener mantenimientos activos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveMaintenanceForVehicle(vehicleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Maintenance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveMaintenanceForVehicle(vehicleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.getActiveMaintenanceForVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la lista completa de mantenimientos registrados
         * @summary Obtener todos los mantenimientos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMaintenance(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Maintenance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMaintenance(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.getAllMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna un mantenimiento específico
         * @summary Obtener mantenimiento por ID
         * @param {number} id ID del mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Maintenance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.getMaintenanceById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna mantenimientos filtrados por tipo
         * @summary Obtener mantenimientos por tipo
         * @param {GetMaintenanceByTypeTypeEnum} type Tipo de mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceByType(type: GetMaintenanceByTypeTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Maintenance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceByType(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.getMaintenanceByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los mantenimientos de un vehículo específico
         * @summary Obtener mantenimientos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMaintenanceByVehicle(vehicleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Maintenance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMaintenanceByVehicle(vehicleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.getMaintenanceByVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna mantenimientos programados en un rango de fechas
         * @summary Obtener mantenimientos próximos
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpcomingMaintenance(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Maintenance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpcomingMaintenance(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.getUpcomingMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Programa un nuevo mantenimiento para un vehículo
         * @summary Programar mantenimiento
         * @param {string} vehicleId ID del vehículo
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {ScheduleMaintenanceTypeEnum} type Tipo de mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleMaintenance(vehicleId: string, startDate: string, type: ScheduleMaintenanceTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Maintenance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleMaintenance(vehicleId, startDate, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MaintenanceApi.scheduleMaintenance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MaintenanceApi - factory interface
 * @export
 */
export const MaintenanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MaintenanceApiFp(configuration)
    return {
        /**
         * Marca un mantenimiento como completado
         * @summary Completar mantenimiento
         * @param {number} id ID del mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeMaintenance(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Maintenance> {
            return localVarFp.completeMaintenance(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Registra un nuevo mantenimiento en el sistema
         * @summary Crear nuevo mantenimiento
         * @param {Maintenance} maintenance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMaintenance(maintenance: Maintenance, options?: RawAxiosRequestConfig): AxiosPromise<Maintenance> {
            return localVarFp.createMaintenance(maintenance, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los mantenimientos actualmente en curso
         * @summary Obtener mantenimientos activos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveMaintenance(options?: RawAxiosRequestConfig): AxiosPromise<Array<Maintenance>> {
            return localVarFp.getActiveMaintenance(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna mantenimientos activos de un vehículo específico
         * @summary Obtener mantenimientos activos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveMaintenanceForVehicle(vehicleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Maintenance>> {
            return localVarFp.getActiveMaintenanceForVehicle(vehicleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la lista completa de mantenimientos registrados
         * @summary Obtener todos los mantenimientos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMaintenance(options?: RawAxiosRequestConfig): AxiosPromise<Maintenance> {
            return localVarFp.getAllMaintenance(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna un mantenimiento específico
         * @summary Obtener mantenimiento por ID
         * @param {number} id ID del mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Maintenance> {
            return localVarFp.getMaintenanceById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna mantenimientos filtrados por tipo
         * @summary Obtener mantenimientos por tipo
         * @param {GetMaintenanceByTypeTypeEnum} type Tipo de mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceByType(type: GetMaintenanceByTypeTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Maintenance>> {
            return localVarFp.getMaintenanceByType(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los mantenimientos de un vehículo específico
         * @summary Obtener mantenimientos por vehículo
         * @param {string} vehicleId ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMaintenanceByVehicle(vehicleId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Maintenance>> {
            return localVarFp.getMaintenanceByVehicle(vehicleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna mantenimientos programados en un rango de fechas
         * @summary Obtener mantenimientos próximos
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpcomingMaintenance(startDate: string, endDate: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Maintenance>> {
            return localVarFp.getUpcomingMaintenance(startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Programa un nuevo mantenimiento para un vehículo
         * @summary Programar mantenimiento
         * @param {string} vehicleId ID del vehículo
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {ScheduleMaintenanceTypeEnum} type Tipo de mantenimiento
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleMaintenance(vehicleId: string, startDate: string, type: ScheduleMaintenanceTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Maintenance> {
            return localVarFp.scheduleMaintenance(vehicleId, startDate, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MaintenanceApi - object-oriented interface
 * @export
 * @class MaintenanceApi
 * @extends {BaseAPI}
 */
export class MaintenanceApi extends BaseAPI {
    /**
     * Marca un mantenimiento como completado
     * @summary Completar mantenimiento
     * @param {number} id ID del mantenimiento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public completeMaintenance(id: number, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).completeMaintenance(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registra un nuevo mantenimiento en el sistema
     * @summary Crear nuevo mantenimiento
     * @param {Maintenance} maintenance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public createMaintenance(maintenance: Maintenance, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).createMaintenance(maintenance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los mantenimientos actualmente en curso
     * @summary Obtener mantenimientos activos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public getActiveMaintenance(options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).getActiveMaintenance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna mantenimientos activos de un vehículo específico
     * @summary Obtener mantenimientos activos por vehículo
     * @param {string} vehicleId ID del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public getActiveMaintenanceForVehicle(vehicleId: string, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).getActiveMaintenanceForVehicle(vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la lista completa de mantenimientos registrados
     * @summary Obtener todos los mantenimientos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public getAllMaintenance(options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).getAllMaintenance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna un mantenimiento específico
     * @summary Obtener mantenimiento por ID
     * @param {number} id ID del mantenimiento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public getMaintenanceById(id: number, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).getMaintenanceById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna mantenimientos filtrados por tipo
     * @summary Obtener mantenimientos por tipo
     * @param {GetMaintenanceByTypeTypeEnum} type Tipo de mantenimiento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public getMaintenanceByType(type: GetMaintenanceByTypeTypeEnum, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).getMaintenanceByType(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los mantenimientos de un vehículo específico
     * @summary Obtener mantenimientos por vehículo
     * @param {string} vehicleId ID del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public getMaintenanceByVehicle(vehicleId: string, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).getMaintenanceByVehicle(vehicleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna mantenimientos programados en un rango de fechas
     * @summary Obtener mantenimientos próximos
     * @param {string} startDate Fecha de inicio (ISO 8601)
     * @param {string} endDate Fecha de fin (ISO 8601)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public getUpcomingMaintenance(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).getUpcomingMaintenance(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Programa un nuevo mantenimiento para un vehículo
     * @summary Programar mantenimiento
     * @param {string} vehicleId ID del vehículo
     * @param {string} startDate Fecha de inicio (ISO 8601)
     * @param {ScheduleMaintenanceTypeEnum} type Tipo de mantenimiento
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MaintenanceApi
     */
    public scheduleMaintenance(vehicleId: string, startDate: string, type: ScheduleMaintenanceTypeEnum, options?: RawAxiosRequestConfig) {
        return MaintenanceApiFp(this.configuration).scheduleMaintenance(vehicleId, startDate, type, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetMaintenanceByTypeTypeEnum = {
    Preventive: 'PREVENTIVE',
    Corrective: 'CORRECTIVE'
} as const;
export type GetMaintenanceByTypeTypeEnum = typeof GetMaintenanceByTypeTypeEnum[keyof typeof GetMaintenanceByTypeTypeEnum];
/**
 * @export
 */
export const ScheduleMaintenanceTypeEnum = {
    Preventive: 'PREVENTIVE',
    Corrective: 'CORRECTIVE'
} as const;
export type ScheduleMaintenanceTypeEnum = typeof ScheduleMaintenanceTypeEnum[keyof typeof ScheduleMaintenanceTypeEnum];


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
      /**
       * Registra una nueva orden en el sistema
       * @summary Crear nueva orden
       * @param {Order} order
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      createOrder: async (
        order: Order,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'order' is not null or undefined
        assertParamExists("createOrder", "order", order);
        const localVarPath = `/api/orders`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "POST",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        localVarHeaderParameter["Content-Type"] = "application/json";

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };
        localVarRequestOptions.data = serializeDataIfNeeded(
          order,
          localVarRequestOptions,
          configuration
        );

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Elimina una orden del sistema
       * @summary Eliminar orden
       * @param {string} id ID de la orden a eliminar
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      deleteOrder: async (
        id: string,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'id' is not null or undefined
        assertParamExists("deleteOrder", "id", id);
        const localVarPath = `/api/orders/{id}`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(id))
        );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "DELETE",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna la lista completa de órdenes registradas
       * @summary Obtener todas las órdenes
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getAllOrders: async (
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        const localVarPath = `/api/orders`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna todas las órdenes que han sido completadas
       * @summary Obtener órdenes completadas
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getCompletedOrders: async (
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        const localVarPath = `/api/orders/completed`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna una orden específica
       * @summary Obtener orden por ID
       * @param {string} id ID de la orden
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getOrderById: async (
        id: string,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'id' is not null or undefined
        assertParamExists("getOrderById", "id", id);
        const localVarPath = `/api/orders/{id}`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(id))
        );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna órdenes en un rango de fechas específico
       * @summary Obtener órdenes por rango de fechas
       * @param {string} startDate Fecha de inicio (ISO 8601)
       * @param {string} endDate Fecha de fin (ISO 8601)
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getOrdersByDateRange: async (
        startDate: string,
        endDate: string,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'startDate' is not null or undefined
        assertParamExists("getOrdersByDateRange", "startDate", startDate);
        // verify required parameter 'endDate' is not null or undefined
        assertParamExists("getOrdersByDateRange", "endDate", endDate);
        const localVarPath = `/api/orders/date-range`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (startDate !== undefined) {
          localVarQueryParameter["startDate"] = startDate;
        }

        if (endDate !== undefined) {
          localVarQueryParameter["endDate"] = endDate;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna órdenes que deben ser entregadas antes de una fecha específica
       * @summary Obtener órdenes por fecha límite
       * @param {string} time Fecha límite (ISO 8601)
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getOrdersByDueTime: async (
        time: string,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'time' is not null or undefined
        assertParamExists("getOrdersByDueTime", "time", time);
        const localVarPath = `/api/orders/due-by`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (time !== undefined) {
          localVarQueryParameter["time"] = time;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna órdenes dentro de un radio específico desde una posición
       * @summary Obtener órdenes por radio
       * @param {number} x Coordenada X del centro
       * @param {number} y Coordenada Y del centro
       * @param {number} radius Radio de búsqueda
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getOrdersByRadius: async (
        x: number,
        y: number,
        radius: number,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'x' is not null or undefined
        assertParamExists("getOrdersByRadius", "x", x);
        // verify required parameter 'y' is not null or undefined
        assertParamExists("getOrdersByRadius", "y", y);
        // verify required parameter 'radius' is not null or undefined
        assertParamExists("getOrdersByRadius", "radius", radius);
        const localVarPath = `/api/orders/radius`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (x !== undefined) {
          localVarQueryParameter["x"] = x;
        }

        if (y !== undefined) {
          localVarQueryParameter["y"] = y;
        }

        if (radius !== undefined) {
          localVarQueryParameter["radius"] = radius;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna todas las órdenes que han superado su fecha límite
       * @summary Obtener órdenes vencidas
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getOverdueOrders: async (
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        const localVarPath = `/api/orders/overdue`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna todas las órdenes que están pendientes de entrega
       * @summary Obtener órdenes pendientes
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getPendingOrders: async (
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        const localVarPath = `/api/orders/pending`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Retorna órdenes que deben ser entregadas en las próximas horas
       * @summary Obtener órdenes urgentes
       * @param {number} [hoursAhead] Horas hacia adelante para considerar urgente
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      getUrgentOrders: async (
        hoursAhead?: number,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        const localVarPath = `/api/orders/urgent`;
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (hoursAhead !== undefined) {
          localVarQueryParameter["hoursAhead"] = hoursAhead;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      /**
       * Registra la entrega de una cantidad específica de GLP para una orden
       * @summary Registrar entrega
       * @param {string} id ID de la orden
       * @param {number} amount Volumen entregado
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       */
      recordDelivery: async (
        id: string,
        amount: number,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'id' is not null or undefined
        assertParamExists("recordDelivery", "id", id);
        // verify required parameter 'amount' is not null or undefined
        assertParamExists("recordDelivery", "amount", amount);
        const localVarPath = `/api/orders/{id}/deliver`.replace(
          `{${"id"}}`,
          encodeURIComponent(String(id))
        );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "PUT",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        if (amount !== undefined) {
          localVarQueryParameter["amount"] = amount;
        }

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
      getOrdersByStatus: async (
        status: GetOrdersByStatusStatusEnum,
        options: RawAxiosRequestConfig = {}
      ): Promise<RequestArgs> => {
        // verify required parameter 'status' is not null or undefined
        assertParamExists("getOrdersByStatus", "status", status);
        const localVarPath = `/api/orders/status/{status}`.replace(
          `{${"status"}}`,
          encodeURIComponent(String(status))
        );
        // use dummy base URL string because the URL constructor only accepts absolute URLs.
        const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
        let baseOptions;
        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = {
          method: "GET",
          ...baseOptions,
          ...options,
        };
        const localVarHeaderParameter = {} as any;
        const localVarQueryParameter = {} as any;

        setSearchParams(localVarUrlObj, localVarQueryParameter);
        let headersFromBaseOptions =
          baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = {
          ...localVarHeaderParameter,
          ...headersFromBaseOptions,
          ...options.headers,
        };

        return {
          url: toPathString(localVarUrlObj),
          options: localVarRequestOptions,
        };
      },
    };
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Registra una nueva orden en el sistema
         * @summary Crear nueva orden
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(order: Order, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(order, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.createOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina una orden del sistema
         * @summary Eliminar orden
         * @param {string} id ID de la orden a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.deleteOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la lista completa de órdenes registradas
         * @summary Obtener todas las órdenes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getAllOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todas las órdenes que han sido completadas
         * @summary Obtener órdenes completadas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompletedOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompletedOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getCompletedOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna una orden específica
         * @summary Obtener orden por ID
         * @param {string} id ID de la orden
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrderById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna órdenes en un rango de fechas específico
         * @summary Obtener órdenes por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersByDateRange(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrdersByDateRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna órdenes que deben ser entregadas antes de una fecha específica
         * @summary Obtener órdenes por fecha límite
         * @param {string} time Fecha límite (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersByDueTime(time: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersByDueTime(time, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrdersByDueTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna órdenes dentro de un radio específico desde una posición
         * @summary Obtener órdenes por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersByRadius(x, y, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrdersByRadius']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todas las órdenes que han superado su fecha límite
         * @summary Obtener órdenes vencidas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOverdueOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOverdueOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOverdueOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todas las órdenes que están pendientes de entrega
         * @summary Obtener órdenes pendientes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPendingOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPendingOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getPendingOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna órdenes que deben ser entregadas en las próximas horas
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas hacia adelante para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUrgentOrders(hoursAhead, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getUrgentOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registra la entrega de una cantidad específica de GLP para una orden
         * @summary Registrar entrega
         * @param {string} id ID de la orden
         * @param {number} amount Volumen entregado
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordDelivery(id: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordDelivery(id, amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.recordDelivery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        async getOrdersByStatus(status: GetOrdersByStatusStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
    const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersByStatus(status, options);
    const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
    const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrdersByStatus']?.[localVarOperationServerIndex]?.url;
    return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
},

    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Registra una nueva orden en el sistema
         * @summary Crear nueva orden
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(order: Order, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.createOrder(order, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina una orden del sistema
         * @summary Eliminar orden
         * @param {string} id ID de la orden a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la lista completa de órdenes registradas
         * @summary Obtener todas las órdenes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrders(options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.getAllOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todas las órdenes que han sido completadas
         * @summary Obtener órdenes completadas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompletedOrders(options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getCompletedOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna una orden específica
         * @summary Obtener orden por ID
         * @param {string} id ID de la orden
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Order> {
            return localVarFp.getOrderById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna órdenes en un rango de fechas específico
         * @summary Obtener órdenes por rango de fechas
         * @param {string} startDate Fecha de inicio (ISO 8601)
         * @param {string} endDate Fecha de fin (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getOrdersByDateRange(startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna órdenes que deben ser entregadas antes de una fecha específica
         * @summary Obtener órdenes por fecha límite
         * @param {string} time Fecha límite (ISO 8601)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByDueTime(time: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getOrdersByDueTime(time, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna órdenes dentro de un radio específico desde una posición
         * @summary Obtener órdenes por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getOrdersByRadius(x, y, radius, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todas las órdenes que han superado su fecha límite
         * @summary Obtener órdenes vencidas
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueOrders(options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getOverdueOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todas las órdenes que están pendientes de entrega
         * @summary Obtener órdenes pendientes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPendingOrders(options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getPendingOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna órdenes que deben ser entregadas en las próximas horas
         * @summary Obtener órdenes urgentes
         * @param {number} [hoursAhead] Horas hacia adelante para considerar urgente
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Order>> {
            return localVarFp.getUrgentOrders(hoursAhead, options).then((request) => request(axios, basePath));
        },
      


    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Registra una nueva orden en el sistema
     * @summary Crear nueva orden
     * @param {Order} order 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public createOrder(order: Order, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).createOrder(order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina una orden del sistema
     * @summary Eliminar orden
     * @param {string} id ID de la orden a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deleteOrder(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deleteOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la lista completa de órdenes registradas
     * @summary Obtener todas las órdenes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getAllOrders(options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getAllOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todas las órdenes que han sido completadas
     * @summary Obtener órdenes completadas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getCompletedOrders(options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getCompletedOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna una orden específica
     * @summary Obtener orden por ID
     * @param {string} id ID de la orden
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrderById(id: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrderById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna órdenes en un rango de fechas específico
     * @summary Obtener órdenes por rango de fechas
     * @param {string} startDate Fecha de inicio (ISO 8601)
     * @param {string} endDate Fecha de fin (ISO 8601)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersByDateRange(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrdersByDateRange(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna órdenes que deben ser entregadas antes de una fecha específica
     * @summary Obtener órdenes por fecha límite
     * @param {string} time Fecha límite (ISO 8601)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersByDueTime(time: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrdersByDueTime(time, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna órdenes dentro de un radio específico desde una posición
     * @summary Obtener órdenes por radio
     * @param {number} x Coordenada X del centro
     * @param {number} y Coordenada Y del centro
     * @param {number} radius Radio de búsqueda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrdersByRadius(x, y, radius, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todas las órdenes que han superado su fecha límite
     * @summary Obtener órdenes vencidas
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOverdueOrders(options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOverdueOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todas las órdenes que están pendientes de entrega
     * @summary Obtener órdenes pendientes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getPendingOrders(options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getPendingOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna órdenes que deben ser entregadas en las próximas horas
     * @summary Obtener órdenes urgentes
     * @param {number} [hoursAhead] Horas hacia adelante para considerar urgente
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getUrgentOrders(hoursAhead?: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getUrgentOrders(hoursAhead, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registra la entrega de una cantidad específica de GLP para una orden
     * @summary Registrar entrega
     * @param {string} id ID de la orden
     * @param {number} amount Volumen entregado
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public recordDelivery(id: string, amount: number, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).recordDelivery(id, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
 * Retorna órdenes filtradas por estado
 * @summary Obtener órdenes por estado
 * @param {GetOrdersByStatusStatusEnum} status Estado de la orden
 * @param {*} [options] Override http request option.
 * @throws {RequiredError}
 * @memberof OrdersApi
 */
public getOrdersByStatus(status: GetOrdersByStatusStatusEnum, options?: RawAxiosRequestConfig) {
    return OrdersApiFp(this.configuration).getOrdersByStatus(status, options).then((request) => request(this.axios, this.basePath));
}

}



/**
 * VehiclesApi - axios parameter creator
 * @export
 */
export const VehiclesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Crea un nuevo vehículo en el sistema
         * @summary Crear nuevo vehículo
         * @param {Vehicle} vehicle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVehicle: async (vehicle: Vehicle, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicle' is not null or undefined
            assertParamExists('createVehicle', 'vehicle', vehicle)
            const localVarPath = `/api/vehicles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vehicle, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Elimina un vehículo del sistema
         * @summary Eliminar vehículo
         * @param {string} id ID del vehículo a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVehicle: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteVehicle', 'id', id)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna una lista de todos los vehículos en el sistema
         * @summary Obtener todos los vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna el total de GLP disponible en vehículos disponibles
         * @summary Obtener GLP disponible en la flota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFleetGLP: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicles/fleet/available-glp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna todos los vehículos disponibles
         * @summary Obtener vehículos disponibles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableVehicles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicles/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna la capacidad total de GLP de todos los vehículos
         * @summary Obtener capacidad total de la flota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalFleetCapacity: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicles/fleet/capacity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna un vehículo específico por su ID
         * @summary Obtener vehículo por ID
         * @param {string} id ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getVehicleById', 'id', id)
            const localVarPath = `/api/vehicles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna vehículos dentro de un radio específico
         * @summary Obtener vehículos por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehiclesByRadius: async (x: number, y: number, radius: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'x' is not null or undefined
            assertParamExists('getVehiclesByRadius', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('getVehiclesByRadius', 'y', y)
            // verify required parameter 'radius' is not null or undefined
            assertParamExists('getVehiclesByRadius', 'radius', radius)
            const localVarPath = `/api/vehicles/radius`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (x !== undefined) {
                localVarQueryParameter['x'] = x;
            }

            if (y !== undefined) {
                localVarQueryParameter['y'] = y;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna vehículos filtrados por estado
         * @summary Obtener vehículos por estado
         * @param {GetVehiclesByStatusStatusEnum} status Estado del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehiclesByStatus: async (status: GetVehiclesByStatusStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('getVehiclesByStatus', 'status', status)
            const localVarPath = `/api/vehicles/status/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retorna vehículos filtrados por tipo
         * @summary Obtener vehículos por tipo
         * @param {GetVehiclesByTypeTypeEnum} type Tipo de vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehiclesByType: async (type: GetVehiclesByTypeTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getVehiclesByType', 'type', type)
            const localVarPath = `/api/vehicles/type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza el nivel de GLP del vehículo (cantidad a agregar/quitar)
         * @summary Actualizar nivel de GLP
         * @param {string} id ID del vehículo
         * @param {number} amount Cantidad de GLP a agregar (positivo) o quitar (negativo)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGLPLevel: async (id: string, amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateGLPLevel', 'id', id)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('updateGLPLevel', 'amount', amount)
            const localVarPath = `/api/vehicles/{id}/glp`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza la posición actual del vehículo
         * @summary Actualizar posición del vehículo
         * @param {string} id ID del vehículo
         * @param {Position} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVehiclePosition: async (id: string, position: Position, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVehiclePosition', 'id', id)
            // verify required parameter 'position' is not null or undefined
            assertParamExists('updateVehiclePosition', 'position', position)
            const localVarPath = `/api/vehicles/{id}/position`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(position, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Actualiza el estado operacional del vehículo
         * @summary Actualizar estado del vehículo
         * @param {string} id ID del vehículo
         * @param {UpdateVehicleStatusStatusEnum} status Nuevo estado del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVehicleStatus: async (id: string, status: UpdateVehicleStatusStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateVehicleStatus', 'id', id)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateVehicleStatus', 'status', status)
            const localVarPath = `/api/vehicles/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehiclesApi - functional programming interface
 * @export
 */
export const VehiclesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VehiclesApiAxiosParamCreator(configuration)
    return {
        /**
         * Crea un nuevo vehículo en el sistema
         * @summary Crear nuevo vehículo
         * @param {Vehicle} vehicle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVehicle(vehicle: Vehicle, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVehicle(vehicle, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.createVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Elimina un vehículo del sistema
         * @summary Eliminar vehículo
         * @param {string} id ID del vehículo a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteVehicle(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVehicle(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.deleteVehicle']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna una lista de todos los vehículos en el sistema
         * @summary Obtener todos los vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVehicles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVehicles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getAllVehicles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna el total de GLP disponible en vehículos disponibles
         * @summary Obtener GLP disponible en la flota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableFleetGLP(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableFleetGLP(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getAvailableFleetGLP']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna todos los vehículos disponibles
         * @summary Obtener vehículos disponibles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableVehicles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vehicle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableVehicles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getAvailableVehicles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna la capacidad total de GLP de todos los vehículos
         * @summary Obtener capacidad total de la flota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalFleetCapacity(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalFleetCapacity(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getTotalFleetCapacity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna un vehículo específico por su ID
         * @summary Obtener vehículo por ID
         * @param {string} id ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehicleById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehicleById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getVehicleById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna vehículos dentro de un radio específico
         * @summary Obtener vehículos por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehiclesByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vehicle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehiclesByRadius(x, y, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getVehiclesByRadius']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna vehículos filtrados por estado
         * @summary Obtener vehículos por estado
         * @param {GetVehiclesByStatusStatusEnum} status Estado del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehiclesByStatus(status: GetVehiclesByStatusStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vehicle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehiclesByStatus(status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getVehiclesByStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retorna vehículos filtrados por tipo
         * @summary Obtener vehículos por tipo
         * @param {GetVehiclesByTypeTypeEnum} type Tipo de vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVehiclesByType(type: GetVehiclesByTypeTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vehicle>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVehiclesByType(type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.getVehiclesByType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Actualiza el nivel de GLP del vehículo (cantidad a agregar/quitar)
         * @summary Actualizar nivel de GLP
         * @param {string} id ID del vehículo
         * @param {number} amount Cantidad de GLP a agregar (positivo) o quitar (negativo)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGLPLevel(id: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGLPLevel(id, amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.updateGLPLevel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Actualiza la posición actual del vehículo
         * @summary Actualizar posición del vehículo
         * @param {string} id ID del vehículo
         * @param {Position} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVehiclePosition(id: string, position: Position, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVehiclePosition(id, position, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.updateVehiclePosition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Actualiza el estado operacional del vehículo
         * @summary Actualizar estado del vehículo
         * @param {string} id ID del vehículo
         * @param {UpdateVehicleStatusStatusEnum} status Nuevo estado del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVehicleStatus(id: string, status: UpdateVehicleStatusStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vehicle>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateVehicleStatus(id, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VehiclesApi.updateVehicleStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VehiclesApi - factory interface
 * @export
 */
export const VehiclesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VehiclesApiFp(configuration)
    return {
        /**
         * Crea un nuevo vehículo en el sistema
         * @summary Crear nuevo vehículo
         * @param {Vehicle} vehicle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVehicle(vehicle: Vehicle, options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.createVehicle(vehicle, options).then((request) => request(axios, basePath));
        },
        /**
         * Elimina un vehículo del sistema
         * @summary Eliminar vehículo
         * @param {string} id ID del vehículo a eliminar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVehicle(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteVehicle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna una lista de todos los vehículos en el sistema
         * @summary Obtener todos los vehículos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicles(options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.getAllVehicles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna el total de GLP disponible en vehículos disponibles
         * @summary Obtener GLP disponible en la flota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableFleetGLP(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getAvailableFleetGLP(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna todos los vehículos disponibles
         * @summary Obtener vehículos disponibles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableVehicles(options?: RawAxiosRequestConfig): AxiosPromise<Array<Vehicle>> {
            return localVarFp.getAvailableVehicles(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna la capacidad total de GLP de todos los vehículos
         * @summary Obtener capacidad total de la flota
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalFleetCapacity(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getTotalFleetCapacity(options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna un vehículo específico por su ID
         * @summary Obtener vehículo por ID
         * @param {string} id ID del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehicleById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.getVehicleById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna vehículos dentro de un radio específico
         * @summary Obtener vehículos por radio
         * @param {number} x Coordenada X del centro
         * @param {number} y Coordenada Y del centro
         * @param {number} radius Radio de búsqueda
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehiclesByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Vehicle>> {
            return localVarFp.getVehiclesByRadius(x, y, radius, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna vehículos filtrados por estado
         * @summary Obtener vehículos por estado
         * @param {GetVehiclesByStatusStatusEnum} status Estado del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehiclesByStatus(status: GetVehiclesByStatusStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Vehicle>> {
            return localVarFp.getVehiclesByStatus(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Retorna vehículos filtrados por tipo
         * @summary Obtener vehículos por tipo
         * @param {GetVehiclesByTypeTypeEnum} type Tipo de vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVehiclesByType(type: GetVehiclesByTypeTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<Vehicle>> {
            return localVarFp.getVehiclesByType(type, options).then((request) => request(axios, basePath));
        },
        /**
         * Actualiza el nivel de GLP del vehículo (cantidad a agregar/quitar)
         * @summary Actualizar nivel de GLP
         * @param {string} id ID del vehículo
         * @param {number} amount Cantidad de GLP a agregar (positivo) o quitar (negativo)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGLPLevel(id: string, amount: number, options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.updateGLPLevel(id, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Actualiza la posición actual del vehículo
         * @summary Actualizar posición del vehículo
         * @param {string} id ID del vehículo
         * @param {Position} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVehiclePosition(id: string, position: Position, options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.updateVehiclePosition(id, position, options).then((request) => request(axios, basePath));
        },
        /**
         * Actualiza el estado operacional del vehículo
         * @summary Actualizar estado del vehículo
         * @param {string} id ID del vehículo
         * @param {UpdateVehicleStatusStatusEnum} status Nuevo estado del vehículo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVehicleStatus(id: string, status: UpdateVehicleStatusStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Vehicle> {
            return localVarFp.updateVehicleStatus(id, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VehiclesApi - object-oriented interface
 * @export
 * @class VehiclesApi
 * @extends {BaseAPI}
 */
export class VehiclesApi extends BaseAPI {
    /**
     * Crea un nuevo vehículo en el sistema
     * @summary Crear nuevo vehículo
     * @param {Vehicle} vehicle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public createVehicle(vehicle: Vehicle, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).createVehicle(vehicle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Elimina un vehículo del sistema
     * @summary Eliminar vehículo
     * @param {string} id ID del vehículo a eliminar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public deleteVehicle(id: string, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).deleteVehicle(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna una lista de todos los vehículos en el sistema
     * @summary Obtener todos los vehículos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getAllVehicles(options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getAllVehicles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna el total de GLP disponible en vehículos disponibles
     * @summary Obtener GLP disponible en la flota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getAvailableFleetGLP(options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getAvailableFleetGLP(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna todos los vehículos disponibles
     * @summary Obtener vehículos disponibles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getAvailableVehicles(options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getAvailableVehicles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna la capacidad total de GLP de todos los vehículos
     * @summary Obtener capacidad total de la flota
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getTotalFleetCapacity(options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getTotalFleetCapacity(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna un vehículo específico por su ID
     * @summary Obtener vehículo por ID
     * @param {string} id ID del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getVehicleById(id: string, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getVehicleById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna vehículos dentro de un radio específico
     * @summary Obtener vehículos por radio
     * @param {number} x Coordenada X del centro
     * @param {number} y Coordenada Y del centro
     * @param {number} radius Radio de búsqueda
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getVehiclesByRadius(x: number, y: number, radius: number, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getVehiclesByRadius(x, y, radius, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna vehículos filtrados por estado
     * @summary Obtener vehículos por estado
     * @param {GetVehiclesByStatusStatusEnum} status Estado del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getVehiclesByStatus(status: GetVehiclesByStatusStatusEnum, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getVehiclesByStatus(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retorna vehículos filtrados por tipo
     * @summary Obtener vehículos por tipo
     * @param {GetVehiclesByTypeTypeEnum} type Tipo de vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public getVehiclesByType(type: GetVehiclesByTypeTypeEnum, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).getVehiclesByType(type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Actualiza el nivel de GLP del vehículo (cantidad a agregar/quitar)
     * @summary Actualizar nivel de GLP
     * @param {string} id ID del vehículo
     * @param {number} amount Cantidad de GLP a agregar (positivo) o quitar (negativo)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public updateGLPLevel(id: string, amount: number, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).updateGLPLevel(id, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Actualiza la posición actual del vehículo
     * @summary Actualizar posición del vehículo
     * @param {string} id ID del vehículo
     * @param {Position} position 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public updateVehiclePosition(id: string, position: Position, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).updateVehiclePosition(id, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Actualiza el estado operacional del vehículo
     * @summary Actualizar estado del vehículo
     * @param {string} id ID del vehículo
     * @param {UpdateVehicleStatusStatusEnum} status Nuevo estado del vehículo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public updateVehicleStatus(id: string, status: UpdateVehicleStatusStatusEnum, options?: RawAxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).updateVehicleStatus(id, status, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetVehiclesByStatusStatusEnum = {
    Available: 'AVAILABLE',
    InTransit: 'IN_TRANSIT',
    Maintenance: 'MAINTENANCE',
    BrokenDown: 'BROKEN_DOWN'
} as const;
export type GetVehiclesByStatusStatusEnum = typeof GetVehiclesByStatusStatusEnum[keyof typeof GetVehiclesByStatusStatusEnum];
/**
 * @export
 */
export const GetVehiclesByTypeTypeEnum = {
    Ta: 'TA',
    Tb: 'TB',
    Tc: 'TC',
    Td: 'TD'
} as const;
export type GetVehiclesByTypeTypeEnum = typeof GetVehiclesByTypeTypeEnum[keyof typeof GetVehiclesByTypeTypeEnum];
/**
 * @export
 */
export const UpdateVehicleStatusStatusEnum = {
    Available: 'AVAILABLE',
    InTransit: 'IN_TRANSIT',
    Maintenance: 'MAINTENANCE',
    BrokenDown: 'BROKEN_DOWN'
} as const;
export type UpdateVehicleStatusStatusEnum = typeof UpdateVehicleStatusStatusEnum[keyof typeof UpdateVehicleStatusStatusEnum];

export const GetOrdersByStatusStatusEnum = {
  Pending: 'PENDING',
  InTransit: 'IN_TRANSIT',
  Delivered: 'DELIVERED',
  Cancelled: 'CANCELLED',
} as const;

export type GetOrdersByStatusStatusEnum = typeof GetOrdersByStatusStatusEnum[keyof typeof GetOrdersByStatusStatusEnum];

